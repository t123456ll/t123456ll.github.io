<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 144.Binary Tree Preorder Traversal (English version)</title>
    <url>/LeetCode-144-Binary-Tree-Preorder-Traversal%20copy.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这里是英文版，中文版<a href="https://t123456ll.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%EF%BC%89%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89%E4%BB%A5%E5%8F%8A%20Morris%20Traversal.html">这里</a></p>
<h2 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">here</a></h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.<br>what’s preorder，inorder and postorder，click <a href="https://en.wikipedia.org/wiki/Tree_traversal" target="_blank" rel="noopener">here</a></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><pre><code>Input: [1,null,2,3]
  1
   \
    2
   /
  3
Output: [1,2,3]</code></pre><p>This problem is very simple to use recursion, traversal all of them. but because there are two common methods for traversal: one is recursive, and the other is iterative version using stack implementation (stack + iterative). These two methods are both O (n) space complexity (recursion itself occupies stack space or user-defined stack), but how to make the space complexity O (1)?</p>
<a id="more"></a>

<h1 id="Solution-Morris-Traversal"><a href="#Solution-Morris-Traversal" class="headerlink" title="Solution: Morris Traversal"></a>Solution: Morris Traversal</h1><p>reference is <a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">here</a> and <a href="https://ghh3809.github.io/2018/08/06/morris-traversal/" target="_blank" rel="noopener">here</a>, you can take a look first. BUT both of them are chinese😂</p>
<p>This is a magical algorithm that can solve two problems</p>
<ol>
<li>Use O (1) space complexity, that is, use constant space (while time complexity is O (n));</li>
<li>Do not change the shape of the binary tree (intermediate process allows to change its shape)</li>
</ol>
<p>To traverse using O (1) space, the biggest difficulty is how to return to the parent node again when traversing to the child node (assuming that the node does not have a pointer pointing to the parent node), because the stack cannot be used as an auxiliary space. To solve this problem, the Morris method uses the concept of a <a href="https://en.wikipedia.org/wiki/Threaded_binary_tree" target="_blank" rel="noopener">threaded binary tree</a>. In the Morris method, there is no need to assign additional pointers to each node to its predecessor and successor. You only need to use the left and right null pointers in the leaf nodes to point to the predecessor or successor in a certain order, that is enough.</p>
<p>Although this question focuses on <strong>pre-order traversal</strong>, I want to mainly talk about how <strong>in-order traversal</strong> is implemented, because morris traversal is written based on in-order. If you don’t want to read the <a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">article</a> I mentioned before, I can summarize for you: <strong>The three kinds of traversal are exactly the same in the overall process implementation, the only difference is when to output the node (the main difference between the preorder and the in order), or whether to print node in reverse , backward print is the characteristic of the post orde</strong>r. This article uses C ++, and I use Python, but the idea is the same.</p>
<p>First of all, understand what is in-order traversal: the core: visit child before parent</p>
<ol>
<li>If the node still has <strong>left subtree</strong>, you must first visit the <strong>left subtree</strong></li>
<li>When no left subtree is accessible, visit the node and try to access the right subtree</li>
</ol>
<p><img src="https://imgur.com/lldvZuC.jpg" alt><strong>Translation:</strong> Orange: node.  Brown: root node.  Green: leaf node. </p>
<p>​                      Yellow: None.   Arrow: point to the “successor” node</p>
<p>In-order: 0,1,2,3,4,5,6</p>
<p>Each node has a “predecessor” node and a “successor” node. For example, on the example binary tree, 0 is a predecessor node of 1, and 2 is a successor node of 1. Obviously, the in-order traversal can be transformed into the calculation process of subsequent nodes. The calculation method for subsequent nodes is:</p>
<ol>
<li>For node A in which the right subtree exists, its successor is the leftmost node in its right subtree;</li>
<li>For node B without a right subtree, its successor is the first of its bottom-up parent nodes to use it as the left subtree.</li>
</ol>
<p>The subsequent calculation of node A is very simple. However, since the information of the binary tree does not include the information of the parent node, the operation of the second item is very difficult, which is why the stack / queue method was used to store the information of the parent node. <strong>But think about it the other way, although node 1 does not know that node 2 is its successor, node 2 knows that node 1 is its predecessor, so we can find its predecessor (node 1) when we at node 2 currently. Once found, we can temporarily use node 1’s right subtree to store the successor node (node 2) to achieve direct access to the successor node without taking up extra space</strong>. This is the main idea of the Morris traversal algorithm.</p>
<p>Based on the above analysis, we can write the main calculation process of the program:</p>
<ol>
<li>If the left child of the current node is empty, output the current node and use its right child as the current node.</li>
<li>If the left child of the current node is not empty, find the previous node of the current node in the in order traversal in the left subtree of the current node.<br>1) If the right child of the previous node is empty, set its right child to the current node. The current node is updated to the left child of the current node.<br>2) If the right child of the previous node is the current node, reset its right child to empty (restore the shape of the tree). Output the current node. The current node is updated to the right child of the current node.<br><strong>From this we can also notice that this path will be traversed twice, once for marking and once for restoration</strong></li>
<li>Repeat steps 1 and 2 above until the current node is empty.<br><img src="https://imgur.com/7UJKYGT.jpg" alt></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span>(cur):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                print(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur.left</span><br><span class="line">                <span class="keyword">while</span> prev.right <span class="keyword">and</span> prev.right != cur:</span><br><span class="line">                    prev = prev.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev.right:</span><br><span class="line">                    prev.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">if</span> prev.right == cur:</span><br><span class="line">                    prev.right = <span class="literal">None</span></span><br><span class="line">                    print(cur.val)</span><br><span class="line">                    cur = cur.right</span><br></pre></td></tr></table></figure>

<h1 id="Final-code"><a href="#Final-code" class="headerlink" title="Final code:"></a>Final code:</h1><p>The following code is pre-order. we can notice that there is not difference between in-ofrder except the position of print.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = root   <span class="comment">#仅存放两个临时变量，O(1)空间复杂度</span></span><br><span class="line">        <span class="keyword">while</span>(cur):   <span class="comment">#当前节点为空时，说明访问完成</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:   <span class="comment">#左子树不存在时，访问+进入右节点</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:   <span class="comment">#左子树存在，寻找前驱节点。</span></span><br><span class="line">                prev = cur.left</span><br><span class="line">                <span class="keyword">while</span>(prev.right <span class="keyword">and</span> prev.right != cur): <span class="comment">#注意寻找前驱节点时，会不断深入右子树。不加判断时，若前驱节点的右子树已指向自己，会引起死循环</span></span><br><span class="line">                    prev = prev.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev.right:  <span class="comment">#前驱节点未访问过，存放后继节点</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    prev.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># prev.right == cur 前驱节点已访问过，恢复树结构</span></span><br><span class="line">                    prev.right = <span class="literal">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>BinaryTree</tag>
        <tag>MorrisTraversal</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的深度遍历（前序，中序，后序）和广度遍历（层次遍历）以及 Morris Traversal</title>
    <url>/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%EF%BC%89%E5%92%8C%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89%E4%BB%A5%E5%8F%8A%20Morris%20Traversal.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历(DFS)和广度遍历(BFS)，深度遍历有前序(preorder)、中序(inorder)以及后序(postorder)三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆或者队列。</p>
<p>那么什么是前序，中序，后序，广度遍历呢：</p>
<p>Binary tree is a very important data structure. Many other data structures have evolved based on the basics of binary trees. For binary trees, there are depth first search (DFS) and breadth first search (BFS). DFS has three traversal methods: preorder, inorder, and postorder. BFS is the what we usually call level traversal. Because the definition of the tree itself is recursive, using the recursive method to implement the three types of traversal of the tree is not only easy to understand, but the code is very concise. For breadth traversal, it needs the support of other data structures, such as the heap or queue.</p>
<p>So what is preorder, middle order, postorder, breadth traversal:</p>
<a id="more"></a>

<p>比如有如下一颗树 we have a following tree：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<ol>
<li><p>前序 pre-order：123456</p>
<p>根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>Root node —&gt; left node —&gt; right node</p>
</li>
<li><p>中序 in-order：324156</p>
<p>左子树 —&gt; 根结点 —&gt; 右子树</p>
<p>Left node —&gt; root node —&gt; right node</p>
</li>
<li><p>后序 post-order：342651</p>
<p>左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>Left node —&gt; right node —&gt; root node</p>
</li>
<li><p>广度 level-order：125346</p>
</li>
</ol>
<h3 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h3><p>前序，中序，后序都可以通过递归来实现，而且代码比较简洁。但是还可以通过Morris traversal 来实现，至于什么是Morris traversal 请看我的<a href="https://t123456ll.github.io/LeetCode-144-Binary-Tree-Preorder-Traversal.html#more">博文</a></p>
<p>The pre-order, in-order and post-order can be implemented by recursion, and the code is relatively concise. But it can also be achieved through Morris traversal. As for what is Morris traversal, please see my <a href="https://t123456ll.github.io/LeetCode-144-Binary-Tree-Preorder-Traversal.html#more">blog post</a></p>
<h4 id="前序遍历-Pre-order-traversal："><a href="#前序遍历-Pre-order-traversal：" class="headerlink" title="前序遍历 Pre-order traversal："></a><strong>前序遍历 Pre-order traversal：</strong></h4><p>递归实现 Recursion: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal1</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        print(root.val)</span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br></pre></td></tr></table></figure>

<p>Morris Traversal 版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span>(cur):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                print(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur.left</span><br><span class="line">                <span class="keyword">while</span> prev.right <span class="keyword">and</span> prev.right != cur:</span><br><span class="line">                    prev = prev.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev.right:</span><br><span class="line">                    prev.right = cur</span><br><span class="line">                    print(cur.val)</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">if</span> prev.right == cur:</span><br><span class="line">                    prev.right = <span class="literal">None</span></span><br><span class="line">                    cur = cur.right</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历-In-order-traversal："><a href="#中序遍历-In-order-traversal：" class="headerlink" title="中序遍历 In-order traversal："></a><strong>中序遍历 In-order traversal：</strong></h4><p>递归实现 Recursion</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal1</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        print(root.val)</span><br><span class="line">        self.flatten(root.right)</span><br></pre></td></tr></table></figure>

<p>Morris Traversal 版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span>(cur):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                print(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur.left</span><br><span class="line">                <span class="keyword">while</span> prev.right <span class="keyword">and</span> prev.right != cur:</span><br><span class="line">                    prev = prev.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev.right:</span><br><span class="line">                    prev.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">if</span> prev.right == cur:</span><br><span class="line">                    prev.right = <span class="literal">None</span></span><br><span class="line">                    print(cur.val)</span><br><span class="line">                    cur = cur.right</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历-Post-order-traversal："><a href="#后序遍历-Post-order-traversal：" class="headerlink" title="后序遍历 Post-order traversal："></a><strong>后序遍历 Post-order traversal：</strong></h4><p>递归实现 Recursion</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal1</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        print(root.val)</span><br></pre></td></tr></table></figure>

<p>Morris Traversal 版有，但我懒，大家可以自行谷歌 Using google, I am too lazy to write.</p>
<p>由此我们可以发现，对于递归版的前序中序后序遍历，以及morris版的前序和中序，区别只在于输出节点的位置不同。</p>
<p>From this we can find that for the recursive version of the pre-order, in-order and post-order traversal, and the morris version of the pre-order and in-order, the only difference is where return the node.</p>
<h3 id="广度遍历-BFS"><a href="#广度遍历-BFS" class="headerlink" title="广度遍历 BFS:"></a>广度遍历 BFS:</h3><p>以下两段代码都能实现广度遍历，但区别是：</p>
<p>第一段代码的每一个while loop都是对<strong>每一个节点</strong>的操作，第二段代码的每一个while loop都是对<strong>每一层节点</strong>的操作。</p>
<p>The following two pieces of code can achieve breadth traversal, but the difference is: Each while loop of the first piece of code is an operation on <strong>each node</strong>, and each while loop of the second piece of code is an operation on <strong>each layer of nodes</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left: queue.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right: queue.append(cur.right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        cur = root</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                print(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: queue.append(cur.right)</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）<a href="https://blog.csdn.net/My_Jobs/article/details/43451187" target="_blank" rel="noopener">here</a></p>
]]></content>
      <tags>
        <tag>二叉树</tag>
        <tag>Algorithm算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实现完全二叉搜索树</title>
    <url>/%E5%AE%9E%E7%8E%B0%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="实现完全二叉搜索树"><a href="#实现完全二叉搜索树" class="headerlink" title="实现完全二叉搜索树"></a>实现完全二叉搜索树</h2><p>题意：输入元素个数、各元素的值，实现完全二叉搜索树。<br>输入：5<br>1 2 3 4 5<br>输出：4 2 5 1 3</p>
<a id="more"></a>

<p>我们先考虑如何转换成一个BST，而不是complete BST。我们知道一个二叉搜索树在inorder的顺序下是一个递增序列，所以突破口就在于可以先将数列排序好，就相当于我们知道了树的inorder顺序，然后我们将其转化为level-order的顺序输出就可以了。如何转换呢？可以使用递归，观察数列可以发现每次parent node都出现在数列的中间位置。如 12345，那么3就是root node（注意我们现在考虑的是二叉搜索树, 不是完全二叉搜索树）那么很容易就写出了如下递归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(inorder, temp, level)</span>:</span> <span class="comment"># change in-order into pre-order</span></span><br><span class="line">    <span class="keyword">if</span> inorder:</span><br><span class="line">        midIdx = len(inorder) // <span class="number">2</span></span><br><span class="line">        temp.append([inorder[midIdx],level])</span><br><span class="line">        change(inorder[:midIdx], temp, level+<span class="number">1</span>)</span><br><span class="line">        change(inorder[midIdx+<span class="number">1</span>:], temp, level+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>但是我们也注意到实际输出到temp并不是level-order，因为不是按照层的顺序摆放的，而是递归顺序摆放的pre-order。需要根据level排序后才是level-order。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = sorted(temp, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]) <span class="comment"># temp is the level-order of BST</span></span><br></pre></td></tr></table></figure>

<p>重新排序完成，我们就得到了一个BST</p>
<p>既然实现了BST，那如何实现complete BST呢？或者说complete BST和BST有什么区别？区别就是</p>
<blockquote>
<p>The encoding of a Complete Binary Search Tree as an array, A[0,…,n−1]. The root is stored at A[0], the left child of a node at index i is stored at index 2(i + 1) − 1, and its right child at index 2(i + 1).</p>
</blockquote>
<p>简而言之，最底层一定是向左靠齐排满的，只有这样才能满足上面描述的要求。</p>
<p>假设有如下1, 2, ……., 20 总共20个点需要排列，那么BST是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">           11</span><br><span class="line">        /      \</span><br><span class="line">      6         16</span><br><span class="line">     / \       /   \</span><br><span class="line">    3   9    14    19</span><br><span class="line">   /\   /\   /\    /\</span><br><span class="line">  2  5 8 10 13 15 18 20</span><br><span class="line"> /\   /    /      /</span><br><span class="line">1  4 7    12     17</span><br></pre></td></tr></table></figure>

<p>最后一层并没有向左对齐排满，比如5下面就没有子节点。</p>
<p>那么该如何实现？有以下两种方法：</p>
<p>1.方法一</p>
<p>先截取list中间一段可以构成满二叉树的部分(part2)，按照上述方法构造满二叉树。然后再将剩下的部分(part1 &amp; part3)交叉相融，直接添加到数列最后。只要数列长度等于$2^n-1$那么一定可以构成一个满二叉树。截取中间的一段可以使得里面任意一个点都大于part1里所有点，小于part3里所有点。</p>
<p>假设有如下1, 2, ……., 20 总共20个点需要排列，part1=[1, 2, 3].  part2=[4, 5, ……, 18].  part3=[19, 20]</p>
<p>level-order: [11, 7, 15, 5, 9, 13, 17, 4, 6, 8, 10, 12, 14, 16, 18, 1, 19, 2, 20, 3]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              11</span><br><span class="line">         /           \</span><br><span class="line">        7             15</span><br><span class="line">     /     \         /   \</span><br><span class="line">    5       9       13    17</span><br><span class="line">   / \     / \      /\    /\</span><br><span class="line">  4   6   8  10   12 15 16 18</span><br><span class="line"> / \ / \  / </span><br><span class="line">1 19 2 20 3</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="comment"># for things like log() and pow()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildBST</span><span class="params">(A)</span>:</span></span><br><span class="line">    inorder = sorted(A) <span class="comment"># turn A into in-order, the time-complexity of sorted is O(nlogn)</span></span><br><span class="line">    Len = pow(<span class="number">2</span>, int(math.log(len(A), <span class="number">2</span>)))<span class="number">-1</span> <span class="comment"># calculate the length of A's perfect part which can built a complete BST</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># part1 and part3 are the rest of A after being cut, len(part1) should equal or one more than len(part3)</span></span><br><span class="line">    part1 = inorder[: (len(A)-Len+<span class="number">1</span>)//<span class="number">2</span>]</span><br><span class="line">    part2 = inorder[(len(A)-Len+<span class="number">1</span>)//<span class="number">2</span>: (len(A)-Len+<span class="number">1</span>)//<span class="number">2</span>+Len] <span class="comment"># the perfect part of A</span></span><br><span class="line">    part3 = inorder[(len(A)-Len+<span class="number">1</span>)//<span class="number">2</span>+Len: ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Elegantly interleave merge part1 with part3, the combination will be added to the end of complete BST</span></span><br><span class="line">    <span class="comment"># the interleaved combination make it's available to be both the left and right node of any node in the last layer</span></span><br><span class="line">    tmp = (part1, part3)</span><br><span class="line">    partLast = [tmp[i % <span class="number">2</span>].pop(<span class="number">0</span>) <span class="keyword">if</span> tmp[i % <span class="number">2</span>] <span class="keyword">else</span> tmp[<span class="number">1</span> - i % <span class="number">2</span>].pop(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(part1) + len(part3))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change in-order into pre-order</span></span><br><span class="line">    temp = []</span><br><span class="line">    change(part2, temp, <span class="number">0</span>)</span><br><span class="line">    temp = sorted(temp, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]) <span class="comment"># temp is the level-order of BST</span></span><br><span class="line">    ans = [it[<span class="number">0</span>] <span class="keyword">for</span> it <span class="keyword">in</span> temp] + partLast <span class="comment"># the final answer = pre-order BST + combination</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># change list A in place</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        A[i] = ans[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(inorder, temp, level)</span>:</span> <span class="comment"># change in-order into pre-order</span></span><br><span class="line">    <span class="keyword">if</span> inorder:</span><br><span class="line">        midIdx = len(inorder) // <span class="number">2</span></span><br><span class="line">        temp.append([inorder[midIdx],level])</span><br><span class="line">        change(inorder[:midIdx], temp, level+<span class="number">1</span>)</span><br><span class="line">        change(inorder[midIdx+<span class="number">1</span>:], temp, level+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>2.方法二</p>
<p><a href="https://blog.csdn.net/BJR_HJF/article/details/81544721" target="_blank" rel="noopener">参考</a>, 核心思路和方法一差不多，区别只在于如何划分使得这部分list能构成complete BST。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>Algorithm算法</tag>
      </tags>
  </entry>
  <entry>
    <title>191. Number of 1 Bits</title>
    <url>/191.%20Number%20of%201%20Bits.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>
<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two's_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong> above the input represents the signed integer <code>-3</code>.</li>
</ul>
<a id="more"></a>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol>
<li>Counter</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> collections.Counter(str(bin(n)))[<span class="string">'1'</span>]</span><br></pre></td></tr></table></figure>

<p>time complexity: O(n)</p>
<p>Space complexity: O(n)</p>
<ol start="2">
<li>List.count</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bin(n).count(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>

<p>time complexity: O(n)</p>
<p>Space complexity: O(n)</p>
<ol start="3">
<li>&amp;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  101</span><br><span class="line">&amp; 001</span><br><span class="line">-----</span><br><span class="line">  001</span><br></pre></td></tr></table></figure>

<p>So, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(n):</span><br><span class="line">            res += n&amp;<span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence</title>
    <url>/128.%20Longest%20Consecutive%20Sequence.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hard</p>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(<em>n</em>) complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li><p>set (hashmap)</p>
<p>因为要保证O(n)的时间复杂度，所以可以使用set先来保存一下list。这样对每个元素的查询就都是O(1)的时间。</p>
<p>当想要知道最长的连续元素时，我们需要先取n， 然后找他的n-1, n+1在不在set中，但这样难免出现重复查找的情况，比如一串数字3456，无论n遍历到哪一个数字，都会把其他的再查一遍，为了减少这种情况的出现。我们不如直接找到这串数字的开头，也就是3。如何找呢？我们就去找2，也就是（n-1）在不在set中，不在，那3肯定就是开头，那代码也就能出来了，凡是遍历n时n-1在set中，那就直接跳过，只去寻找那些是开头的数字后面到底跟了多少数。结果取最长的</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums = set(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                y = x+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> y <span class="keyword">in</span> nums:</span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">                ans = max(ans, y-x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Add Two Numbers</title>
    <url>/2.Add%20Two%20Numbers.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li><p>递归</p>
<p>代码的亮点在于，</p>
<ol>
<li>使用递归，完美的实现了题目中需要倒置结果的需求。由于需要倒置结果（个位是linked list的头）使用以下代码，就可以在计算的同时，不断向下一位移动。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode ans = <span class="keyword">new</span> ListNode(single);</span><br><span class="line">ans.next = addTwoNumbers(l1.next, l2.next);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = l1.val + l2.val;</span><br><span class="line">            <span class="keyword">int</span> single = sum % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> carry = sum / <span class="number">10</span>;</span><br><span class="line">            ListNode ans = <span class="keyword">new</span> ListNode(single);</span><br><span class="line">            ans.next = addTwoNumbers(l1.next, l2.next);</span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.next = addTwoNumbers(ans.next, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syntax：</p>
<ol>
<li>声明新变量时，一定要声明变量类型</li>
<li>递归调用函数时，直接调用函数名，注意函数的参数一定要与声明类型一致</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Two Sum</title>
    <url>/1.%20Two%20Sum.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>从头开始，准备使用Java再刷一遍题，Java 0基础，syntax，数据结构，慢慢感觉。</p>
<ol>
<li>Brute force</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                    ans[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Syntax: </p>
<ol>
<li><p>java和c++很像，都需要提前声明变量类型</p>
</li>
<li><p>for循环的变量一定要记得声明类型</p>
</li>
<li><p>new <a href="https://blog.csdn.net/ljheee/article/details/52235915" target="_blank" rel="noopener">https://blog.csdn.net/ljheee/article/details/52235915</a></p>
<p><strong>Point originOne</strong> = new Point(23, 94);</p>
<p><strong>Rectangle rectOne</strong> = new Rectangle(originOne, 100, 200);</p>
<p><strong>Rectangle rectTwo</strong> = new Rectangle(50, 100);</p>
<p>第一行创建了一个 Point 类的对象，第二个和第三个线创建一个Rectangle 矩形类的对象。</p>
<p>这些陈述中的每一个都有三个部分（详细讨论）：</p>
<p>声明Declaration：粗体代码是将变量名称与对象类型关联的变量声明。</p>
<p>实例化Instantiating ：new关键字是一个java运算符，它用来创建对象。</p>
<p>初始化Initialization：new运算符，随后调用构造函数(interface)，初始化新创建的对象。</p>
</li>
<li><p>Hash map</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mem = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sub = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mem.containsKey(sub))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, mem.get(sub)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mem.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mem = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sub = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mem.containsKey(sub))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, mem.get(sub)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mem.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/3.%20Longest%203.Substring%20Without%20Repeating%20Characters.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>JAVA刷题ing</p>
<p>Medium</p>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>two point</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; mem = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mem.contains(s.charAt(j)))&#123;</span><br><span class="line">                </span><br><span class="line">                mem.add(s.charAt(j++)); <span class="comment">// after finishing this, j += 1</span></span><br><span class="line">                ans = Math.max(ans, j-i); </span><br><span class="line">                <span class="comment">// this why not j-i+1, because at this time j already plus 1</span></span><br><span class="line">                <span class="comment">// System.out.println("here"+mem+s.charAt(j-1));</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// we move i until find the same element</span></span><br><span class="line">                mem.remove(s.charAt(i++));</span><br><span class="line">                <span class="comment">// System.out.println("d"+mem+s.charAt(j));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Syntax:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set&lt;Character&gt; mem = new HashSet&lt;Character&gt;(); // correct</span><br><span class="line">HashSet&lt;Character&gt; mem = new HashSet&lt;Charater&gt;(); // correct</span><br><span class="line">Set&lt;Character&gt; mem = new Set&lt;Character&gt;(); // wrong Set is abstract; cannot be instantiated</span><br></pre></td></tr></table></figure>

<ol>
<li>关于Hashmap的声明，为什么前面可以是Set后面必须是HashSet，<a href="https://stackoverflow.com/questions/18946657/cannot-instantiate-the-type-set" target="_blank" rel="noopener">这里</a>。总之，Set包括(HashSet, LinkedHashSet or TreeSet)前面是对对象类型的声明，类型可以是总的，或者是具体的，但后面是调用接口，对对象初始化，这里就没有set这一选项了。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;d&quot;+mem+s.charAt(j));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>debug必备。print don’t change the line, but println (means print line next) change line after printing. using ‘+’ to link two string. ‘  ‘ can only be used to one char, “   “ can be used to string.</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>130. Surrounded Regions</title>
    <url>/130.%20Surrounded%20Regions.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically</p>
<a id="more"></a>

<p>首先这题让我想到了数海岛那道题，同样都需要找联通的图案，所以很自然就想到需要dfs来进行联通的遍历，但是由于dfs必然会重复遍历一些点，所以就需要<code>visit</code>来记录哪些点已经遍历过了。</p>
<p>首先，根据观察可以发现，只有边上的<code>O</code>或者是和边上<code>O</code>连起来的<code>O</code>才不会被变成<code>X</code>。所以我的思路很简单，就是遍历除边上以外的<code>O</code>，再通过dfs查找他是否于边上的<code>O</code>连着。但是时间复杂度一想就很高。</p>
<p>然后我想到利用<code>visit</code>在dfs的过程中就标记好联通的<code>O</code>然后一起改成<code>X</code>，这部分代码暂定</p>
<p>最后看了<a href="https://leetcode.wang/leetcode-130-Surrounded-Regions.html" target="_blank" rel="noopener">别人的思路</a>。感觉很有道理。</p>
<p><em>解法一是从当前节点做 <code>DFS</code> ，然后看它是否能到达边界的 <code>O</code>。那么我们能不能把思路逆转过来呢？从边界的 <code>O</code> 做 <code>DFS</code>，然后把遇到的 <code>O</code> 都标记一下，这些 <code>O</code> 就是可以连通到边界的。然后把边界的所有的 <code>O</code> 都做一次 <code>DFS</code> ，把 <code>DFS</code> 过程的中的 <code>O</code> 做一下标记。最后我们只需要遍历节点，把没有标记过的 <code>O</code> 改成 <code>X</code> 就可以了。标记的话，我们可以用一个 <code>visited</code> 二维数组，把访问过的置为 <code>true</code> 。</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board: <span class="keyword">return</span></span><br><span class="line">        r = len(board)</span><br><span class="line">        c = len(board[<span class="number">0</span>])</span><br><span class="line">        visit = [[<span class="literal">False</span>]*c <span class="keyword">for</span> i <span class="keyword">in</span> range(r)] <span class="comment"># record if this spot has been visited</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, c):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> i == r<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == c<span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i][j]:</span><br><span class="line">                        self.dfs(i, j, visit, board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, c):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visit[i][j] <span class="keyword">and</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                        </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, i, j, visit, board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;len(board) <span class="keyword">and</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;len(board[<span class="number">0</span>]) <span class="keyword">and</span> j&gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">"O"</span> <span class="keyword">and</span> <span class="keyword">not</span> visit[i][j]: </span><br><span class="line">              <span class="comment"># notic here, without not visit, we can not reach to the recursion end</span></span><br><span class="line">                visit[i][j] = <span class="literal">True</span></span><br><span class="line">                self.dfs(i+<span class="number">1</span>,j,visit,board)</span><br><span class="line">                self.dfs(i,j+<span class="number">1</span>,visit,board)</span><br><span class="line">                self.dfs(i<span class="number">-1</span>,j,visit,board)</span><br><span class="line">                self.dfs(i,j<span class="number">-1</span>,visit,board)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># == "X"</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>同样参考了他的优化改良思路。直接在board上记录，不需要visit</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board: <span class="keyword">return</span></span><br><span class="line">        r = len(board)</span><br><span class="line">        c = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, c):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> i == r<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == c<span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                        self.dfs(i, j, board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, c):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'*'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, i, j, board)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;len(board) <span class="keyword">and</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;len(board[<span class="number">0</span>]) <span class="keyword">and</span> j&gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">"O"</span> :</span><br><span class="line">                board[i][j] = <span class="string">'*'</span></span><br><span class="line">                self.dfs(i+<span class="number">1</span>,j,board)</span><br><span class="line">                self.dfs(i,j+<span class="number">1</span>,board)</span><br><span class="line">                self.dfs(i<span class="number">-1</span>,j,board)</span><br><span class="line">                self.dfs(i,j<span class="number">-1</span>,board)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># == "X"</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>UnionFind 查并集</p>
<p>查并集是什么，可以点<a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">这里</a>。虽然查并集用在这题效率并没有高多少，但是这也不失为一种简单，且容易想到的解题思路。</p>
<p>查并集，算法如其名，两大功能就是查找（found）和合并（Union）。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFound</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, totalNode)</span>:</span></span><br><span class="line">        self.parents = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(totalNode):</span><br><span class="line">            self.parents.append(i)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, node:int)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(self.parents[node] != node):</span><br><span class="line">            self.parents[node] = self.parents[self.parents[node]]</span><br><span class="line">            node = self.parents[node]</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        par1 = self.find(node1)</span><br><span class="line">        par2 = self.find(node2)</span><br><span class="line">        <span class="keyword">if</span> par1 != par2:</span><br><span class="line">            self.parents[par1] = par2 <span class="comment"># not parents[node1] = par2</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnected</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(node1) == self.find(node2)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]: <span class="keyword">return</span> board</span><br><span class="line">        r = len(board)</span><br><span class="line">        c = len(board[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(i, j)</span>:</span> <span class="keyword">return</span> i*c + j <span class="comment"># is c not r</span></span><br><span class="line">        </span><br><span class="line">        uf = UnionFound(r * c + <span class="number">1</span>)</span><br><span class="line">        dummy = r*c </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(c):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span> <span class="keyword">or</span> i==r<span class="number">-1</span> <span class="keyword">or</span> j==c<span class="number">-1</span>:</span><br><span class="line">                        uf.union(node(i,j), dummy)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> board[i<span class="number">-1</span>][j] == <span class="string">'O'</span>: </span><br><span class="line">                            uf.union(node(i<span class="number">-1</span>,j), node(i,j))</span><br><span class="line">                        <span class="keyword">if</span> board[i+<span class="number">1</span>][j] == <span class="string">'O'</span>: </span><br><span class="line">                            uf.union(node(i+<span class="number">1</span>,j), node(i,j))</span><br><span class="line">                        <span class="keyword">if</span> board[i][j<span class="number">-1</span>] == <span class="string">'O'</span>: </span><br><span class="line">                            uf.union(node(i,j<span class="number">-1</span>), node(i,j))</span><br><span class="line">                        <span class="keyword">if</span> board[i][j+<span class="number">1</span>] == <span class="string">'O'</span>: </span><br><span class="line">                            uf.union(node(i,j+<span class="number">1</span>), node(i,j))</span><br><span class="line">                        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(c):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> uf.isConnected(dummy, node(i,j)):</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <url>/123.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hard</p>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>改良版brute force。一维dp list 用来存储一次交易的最大利润。first_idx list存储第一次交易结束时间点，first_max存储第一次交易，ans存两次交易最大值。每次遍历搜索每次潜在的第一次交易结束时间，进行比较，存储结果。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(prices)</span><br><span class="line">        first_idx = [] </span><br><span class="line">        first_max = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> first_idx:</span><br><span class="line">                    second = prices[i] - min(prices[j:i])</span><br><span class="line">                    ans = max(ans, dp[j] + second)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (prices[i] - min(prices[:i])) &gt; first_max:</span><br><span class="line">                    first_max = prices[i] - min(prices[:i])</span><br><span class="line">                    dp[i] = prices[i] - min(prices[:i])</span><br><span class="line">                    first_idx.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i] = first_max</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> max(ans, first_max)</span><br></pre></td></tr></table></figure>

<p>2.使用局部和全局两个dp list</p>
<p>最近在刷动态规划的题，<a href="https://t123456ll.github.io/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20+%20Leetcode120,213%20Solution.html">这篇</a>文章是我写的动态规划一点想法，和大家分享一下</p>
<p>以及这题的<a href="https://www.cnblogs.com/grandyang/p/4281975.html" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span>[] l = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                l[j] = Math.max(g[j-<span class="number">1</span>] + Math.max(<span class="number">0</span>, diff), l[j]+diff);</span><br><span class="line">                g[j] = Math.max(g[j], l[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Syntax:</p>
<ol>
<li>最大值。Math.max。大写</li>
<li>new的用法</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>392. Is Subsequence</title>
    <url>/392.%20Is%20Subsequence.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p>
<p>You may assume that there is only lower case English letters in both <strong>s</strong> and <strong>t</strong>. <strong>t</strong> is potentially a very long (length ~= 500,000) string, and <strong>s</strong> is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Example 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>Return <code>true</code>.</p>
<p><strong>Example 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>Return <code>false</code>.</p>
<p><strong>Follow up:</strong><br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>
<a id="more"></a>

<ol>
<li><p>Iterative</p>
<p>1) index: str.index(str, beg=0, end=len(string)) 找不到会报错</p>
<p>2) find: str.find(str, beg=0, end=len(string)) 找不到return -1</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># must match</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># must not match</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> t:</span><br><span class="line">                idx = t.index(s[<span class="number">0</span>])</span><br><span class="line">                t = t[idx+<span class="number">1</span>:] <span class="comment"># update the target with rest</span></span><br><span class="line">                s = s[<span class="number">1</span>:] <span class="comment"># update the source with rest</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>但是我代码有不好的地方是，查了两遍在不在（一次 in，一次.index），对速度会有影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tem = t.index(c, pos)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pos = tem + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            temp = t.find(c, pos)</span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos = temp + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Off-shelf</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        t = iter(t)</span><br><span class="line">        <span class="keyword">return</span> all(c <span class="keyword">in</span> t <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>746. Min Cost Climbing Stairs</title>
    <url>/746.%20Min%20Cost%20Climbing%20Stairs.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: cost = [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>
<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<a id="more"></a>

<p>最近在刷动态规划的题，<a href="https://t123456ll.github.io/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20+%20Leetcode120,213%20Solution.html">这篇</a>文章是我写的动态规划一点想法，和大家分享一下</p>
<ol>
<li>Dp</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (len(cost)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">            dp[i] = min(dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>从题目中也可以注意到，有些dp的空间是并不需要的，因为我们只需要关注当前位置的前一个(i-1)和前两个(i-2)所以使用两个变量，完全就足够了。</p>
<p>改良版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        f1 = <span class="number">0</span> <span class="comment"># one step behind current position</span></span><br><span class="line">        f2 = <span class="number">0</span> <span class="comment"># two steps behind current postion</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)+<span class="number">1</span>):</span><br><span class="line">            f2, f1 = f1, min(f1 + cost[i<span class="number">-1</span>], f2 + cost[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> f1</span><br></pre></td></tr></table></figure>

<p>⚠️注意： </p>
<ol>
<li>由于题目给的note明确说明cost长度大于等于2，所以不用考虑edge case。</li>
<li>对题目的理解是否准确，并不是跳到cost的最后就结束了(not range(2, len(cost)))，而是要跳出cost (range(2, len(cost)+1))</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>740. Delete and Earn</title>
    <url>/740.%20Delete%20and%20Earn.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p>
<p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p>
<p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [3, 4, 2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">Delete 4 to earn 4 points, consequently 3 is also deleted.</span><br><span class="line">Then, delete 2 to earn 2 points. 6 total points are earned.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [2, 2, 3, 3, 3, 4]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: </span><br><span class="line">Delete 3 to earn 3 points, deleting both 2&apos;s and the 4.</span><br><span class="line">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class="line">9 total points are earned.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li>The length of <code>nums</code> is at most <code>20000</code>.</li>
<li>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</li>
</ul>
<a id="more"></a>

<p>大致看下来，难点在于如何解决不加相邻的数字进去。因为这一题思路可以采取之前小偷偷房子，相邻房子不偷的思路，但是区别在于，这道题给出的的nums 里两个index相邻的数，值不一定是相邻的如[2,3,100]：2，3 index相邻值也相邻，但3，100虽然index相邻但值不相邻。所以我首先想到的是把不相邻的用0填满就可以了。即mem[i]记录值为i的数字总和（同一个数出现不止一次）, 在nums里的值就为 值 * 出现次数，不在就为0。不用字典，counter什么的，是因为他们的key是无序的，而这里我需要一个有序的方便从小到大遍历的list。且list的get item时间复杂度O(1)，跟字典一模样。但这样的坏处也很明显，空间占用太大，不过对于这题<code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>就还好。</p>
<ol>
<li>list 填充0</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># initialize mem to record total point for each n in nums</span></span><br><span class="line">        mem = [<span class="number">0</span>] * (max(nums) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            mem[n] += n</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * len(mem)</span><br><span class="line">        dp[<span class="number">0</span>] = mem[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = mem[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + mem[i], dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>n is the maximum number in the nums</p>
<p>Time complexity: O(n)</p>
<p>Space complexity: O(n)</p>
<ol start="2">
<li><p>改良版</p>
<p>通过写出上面的一维dp array，我们也可以发现，唯一需要用到的信息只集中于当前位置的前两格（dp[i-1], dp[i-2]）再久远的信息根本用不上，所以说根据之前动态规划的想法，我们完全可以把一维矩阵退化为两个变量（take，skip）去记录动态规划信息，正好也解决了空间复杂度的问题</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAndEarn</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        mem = [<span class="number">0</span>] * (max(nums) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            mem[n] += n</span><br><span class="line">        dp = [<span class="number">0</span>] * len(mem)</span><br><span class="line">        </span><br><span class="line">        take, skip = mem[<span class="number">0</span>], mem[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># dp[0] = mem[0]</span></span><br><span class="line">        <span class="comment"># dp[1] = mem[1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">            take, skip = skip, max(take + mem[i], skip)</span><br><span class="line">            <span class="comment"># dp[i] = max(dp[i-2] + mem[i], dp[i-1])</span></span><br><span class="line">        <span class="keyword">return</span> max(take, skip)</span><br></pre></td></tr></table></figure>

<p>跑完以后发现，对于空间复杂度并没有改善多少。思索了一下可能还是因为mem太暴力了。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>377. Combination Sum IV</title>
    <url>/377.%20Combination%20Sum%20IV.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>最近在刷动态规划的题，<a href="https://t123456ll.github.io/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20+%20Leetcode120,213%20Solution.html">这篇</a>文章是我写的动态规划一点想法，和大家分享一下</p>
<p>1.dp</p>
<p>动态规划，dp list是一个（0，target）不断增加的一维矩阵。举例子，nums = [1, 2, 3], target = 5，当amount = 1时只能使用nums里的），当amount = 2时，除了使用nums里的2，还能使用在可以构成amount = 1的情况（也就是1），因为只需在此基础上加nums里的1就可以构成2了，所以dp[2] = 2（0+1+1）。当amount = 3时，除了使用nums里的3，还能使用amount = 2，和amount = 1的情况，dp[3] = 0 + 1(自身) + 1（和为1的组合数） + 2（和为2的组合数） = 4，然后以此类推。</p>
<p>⚠️edge case: 当target = 0时，不加任何数也是一种组合。但没有nums时，没有任何方法可以达到target。这种edge case在换硬币的题里也出现过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i-num &lt; <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i-num == <span class="number">0</span>: dp[i] += dp[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>: dp[i] += dp[i-num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>改良版：</p>
<p>当nums是从小到大排列的，当一个数使得i-num小于0时，后面的num只会更大，所以可以直接break</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i-num &lt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>: dp[i] += dp[i-num]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>速度虽然快了，但time complexity 还是O(n*m), n is the length of nums, m is target. Space complexity is O(m)</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>474. Ones and Zeroes</title>
    <url>/474.%20Ones%20and%20Zeroes.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>
<p>For now, suppose you are a dominator of <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>
<p>Now your task is to find the maximum number of strings that you can form with given <strong>m</strong> <code>0s</code> and <strong>n</strong> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <strong>once</strong>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>
<li>The size of given string array won’t exceed <code>600</code>.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>最近在刷动态规划的题，<a href="https://t123456ll.github.io/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20+%20Leetcode120,213%20Solution.html">这篇</a>文章是我写的动态规划一点想法，和大家分享一下</p>
<p>这题思路也是动态规划，不能用贪心，因为如果你第一反应没有想到用DP来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到0或者1就将对应的m和n的值减小，这种方法在有的时候是不对的，比如对于{“11”, “01”, “10”}，m=2，n=2这个例子，我们将遍历完“11”的时候，把1用完了，那么对于后面两个字符串就没法处理了，而其实正确的答案是应该组成后面两个字符串才对。</p>
<ol>
<li><p>动态规划：</p>
<p>对于dp矩阵的设计和转移方程的寻找。最开始的想法是使用一维dp遍历所有strs，但是发现完完全全是不够的。而且又犯了存储信息太少的错误，根本没有利用上m，n，所以用m，n设计一个二维矩阵就水到渠成。但是问题又来了，写的时候发现如果i, j都是从小到大进行遍历的，而且我们需要 $dp[i - zeros][j - ones]$的上一轮数据，就会发现所需要的数据会被新覆盖，所以不如让其从大到小遍历，这是一个重要的小技巧。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">or</span> (<span class="keyword">not</span> m <span class="keyword">and</span> <span class="keyword">not</span> n): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">            c = Counter(strs[i])</span><br><span class="line">            zeros, ones = c[<span class="string">'0'</span>], c[<span class="string">'1'</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 1</span></span><br><span class="line">                    <span class="keyword">if</span> (i - zeros) &gt;= <span class="number">0</span> <span class="keyword">and</span> (j - ones) &gt;= <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<p>改良版：</p>
<p>因为从大到小遍历，所以i, j只会越来越小，当 (i - zeros) &gt;= 0 and (j - ones) &gt;= 0不满足时，后面也不会满足，不如就不遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs <span class="keyword">or</span> (<span class="keyword">not</span> m <span class="keyword">and</span> <span class="keyword">not</span> n): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">            c = Counter(strs[i])</span><br><span class="line">            zeros, ones = c[<span class="string">'0'</span>], c[<span class="string">'1'</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m, zeros<span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n, ones<span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 1</span></span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<p>Time complexity: $ O(m<em>n</em>l)$ l is the length of strs</p>
<p>Space complexity: $O(mn)$ </p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>720. Longest Word in Dictionary</title>
    <url>/720.%20Longest%20Word%20in%20Dictionary.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given a list of strings <code>words</code> representing an English Dictionary, find the longest word in <code>words</code> that can be built one character at a time by other words in <code>words</code>. If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p>
<p>If there is no answer, return the empty string.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">Output: &quot;world&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">Output: &quot;apple&quot;</span><br><span class="line">Explanation: </span><br><span class="line">Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>All the strings in the input will only contain lowercase letters.</p>
<p>The length of <code>words</code> will be in the range <code>[1, 1000]</code>.</p>
<p>The length of <code>words[i]</code> will be in the range <code>[1, 30]</code>.</p>
<a id="more"></a>

<ol>
<li><p>always start from brute force:</p>
<p>可以使用set来加速查找的时间。然后预先排好序（长度从大到小，字典顺序）找到的第一个符合条件的一定就是最优解</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestWord</span><span class="params">(self, words: List[str])</span> -&gt; str:</span></span><br><span class="line">        wordset = set(words) <span class="comment"># speed up find process</span></span><br><span class="line">        words = sorted(words, key = <span class="keyword">lambda</span> c: (-len(c), c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> all(w[:k] <span class="keyword">in</span> wordset <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, len(w))):</span><br><span class="line">                <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>107. Binary Tree Level Order Traversal II</title>
    <url>/107.%20Binary%20Tree%20Level%20Order%20Traversal%20II.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>Use queue to do level traversal + deque.appendleft or list[ : : -1]  to realize bottom-up</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = deque()</span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span>(q):</span><br><span class="line">            temp = []</span><br><span class="line">            l = len(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                temp.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: q.append(cur.right)</span><br><span class="line">            res.appendleft(temp) <span class="comment"># appendleft to realize bottom up</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span>(q):</span><br><span class="line">            temp = []</span><br><span class="line">            l = len(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                temp.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: q.append(cur.right)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>] <span class="comment"># list[::-1]</span></span><br></pre></td></tr></table></figure>

<p>Time complexity is O(n)</p>
<ol start="2">
<li>DFS + record level</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(res, <span class="number">0</span>, root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, res, level, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; (level + <span class="number">1</span>):</span><br><span class="line">                res.insert(<span class="number">0</span>, [])  <span class="comment"># notice: here insert is O(n)</span></span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            self.dfs(res, level + <span class="number">1</span>, node.left)</span><br><span class="line">            self.dfs(res, level + <span class="number">1</span>, node.right)</span><br></pre></td></tr></table></figure>

<p>So time complexity is O(n^2)</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <url>/145.%20Binary%20Tree%20Postorder%20Traversal.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hard</p>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>

<ol>
<li>Recursive</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            self.dfs(node.left, res)</span><br><span class="line">            self.dfs(node.right, res)</span><br><span class="line">            res.append(node.val)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>684. Redundant Connection</title>
    <url>/684.%20Redundant%20Connection.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>In this problem, a tree is an <strong>undirected</strong> graph that is connected and has noycles.</p>
<p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u, v]</code> with <code>u &lt; v</code>, that represents an <strong>undirected</strong> edge connecting nodes <code>u</code> and <code>v</code>.</p>
<p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge <code>[u, v]</code> should be in the same format, with <code>u &lt; v</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">Output: [1,4]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>Note:</strong></p>
<p>The size of the input 2D-array will be between 3 and 1000.</p>
<p>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</p>
<p><strong>Update (2017-09-26):</strong><br>We have overhauled the problem description + test cases and specified clearly the graph is an <strong><em>undirected\</em></strong> graph. For the <strong><em>directed\</em></strong> graph follow up please see <strong><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">Redundant Connection II</a></strong>). We apologize for any inconvenience caused.</p>
<p>如何去掉多余的一条边，把图变成树，那就是去掉环里的一条边。然后由于有多种答案，我们需要去掉list里最靠后的边，所以我们不如在遍历的时候就开始记录边的关系，当发现加入这条边后能构成一个环，就return这条边。那么如何确定能构成环呢？比如[1,2], [2,3], [1,3]，我们发现[1,3]这条边的两个端点都在同一个线段集([1,2], [2,3])里，那我们不如就使用查并集，这样当两条边能够连接在一起时（有一个端点一样）那我们就把他们归为一组。每次加入新边时，就查找端点u，v是否在同一组，不在说明他们构不成环，在说明他们能构成环。</p>
<p><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">查并集</a></p>
<ol>
<li>Union-Found </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFound</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, totalNode)</span>:</span></span><br><span class="line">        self.parents = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(totalNode):</span><br><span class="line">            self.parents.append(i)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, node:int)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(self.parents[node] != node):</span><br><span class="line">            self.parents[node] = self.parents[self.parents[node]]</span><br><span class="line">            node = self.parents[node]</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        par1 = self.find(node1)</span><br><span class="line">        par2 = self.find(node2)</span><br><span class="line">        <span class="keyword">if</span> par1 != par2:</span><br><span class="line">            self.parents[par1] = par2 <span class="comment"># not parents[node1] = par2</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isConnected</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(node1) == self.find(node2)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> edges: <span class="keyword">return</span> []</span><br><span class="line">        uf = UnionFound(<span class="number">10000</span>) <span class="comment"># can be improved</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> uf.isConnected(e[<span class="number">0</span>], e[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>改良版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> edges: <span class="keyword">return</span> []</span><br><span class="line">        parent = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(v)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> parent.get(v, v) != v:</span><br><span class="line">                v = parent[v]</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> find(e[<span class="number">0</span>]) == find(e[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                parent[find(e[<span class="number">0</span>])] = find(e[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/111.%20Minimum%20Depth%20of%20Binary%20Tree.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its minimum depth = 2.</p>
<a id="more"></a>

<ol>
<li>Recursion:<br>很容易就想到使用递归，但是最开始时对叶子结点的判断方式错了，因为叶子结点应该是not node.right and not node.left，而不是not node。然后每次到达叶子结点就去更新一下最小的depth。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.res = float(<span class="string">'inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, count)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                self.res = min(self.res, count)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> node.left:</span><br><span class="line">                dfs(node.left, count+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">                dfs(node.right, count+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dfs(node.left, count+<span class="number">1</span>)</span><br><span class="line">                dfs(node.right, count+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>BFS</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(q):</span><br><span class="line">            L = len(q)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                <span class="keyword">if</span> cur.right: q.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> cur.left: q.append(cur.left)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>110. Balanced Binary Tree</title>
    <url>/110.%20Balanced%20Binary%20Tree.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>Return true.</p>
<p><strong>Example 2:</strong></p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>Return false.</p>
<p>虽然简单，但仍然不能小看的一道题。判断一棵树是否是平衡二叉树，平衡二叉树定义如下：</p>
<blockquote>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>递归+递归</p>
<p>最外面的递归用来判断一棵树和他的子树是不是平衡二叉树，最里面的递归用来计算左右子树的高度(采用回溯方法计算高度)</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        right = self.getDepth(root.right)</span><br><span class="line">        left = self.getDepth(root.left)</span><br><span class="line">        <span class="keyword">if</span> abs(right - left) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isBalanced(root.right) <span class="keyword">and</span> self.isBalanced(root.left)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = self.getDepth(node.right)</span><br><span class="line">            left = self.getDepth(node.left)</span><br><span class="line">            <span class="keyword">return</span> max(right, left) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 学习笔记</title>
    <url>/HTML%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>教材：<a href="https://www.w3school.com.cn/html/html_jianjie.asp" target="_blank" rel="noopener">W3school</a>, <a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML/Introduction_to_HTML/Getting_started" target="_blank" rel="noopener">MDN web doc</a></p>
<ol>
<li><p>HTML hyper text markup language 超文本标记语言，是用来描述网页的一套语言。不是编程语言而是标记语言。标记语言是一套标记标签 markup tag。</p>
</li>
<li><p>markup tag 标记标签：</p>
<p>成对出现，比如<code>&lt;b&gt; 和 &lt;/b&gt;</code>（没想到typora除了自动识别Markdown，也会识别HTML，可以使用<code>&amp;lt; &amp;gt;</code>  效果 &lt;p&gt;      &lt;/p&gt;），<code>&lt;b&gt;是开始标签，&lt;/b&gt;是结束标签</code> </p>
</li>
<li><p>HTML 文档 = HTML 标签 + 纯文本 = 网页</p>
</li>
<li><p><code>&lt;p&gt;This is a paragraph.&lt;/p&gt;</code></p>
<p><code>&lt;h1&gt;This is a heading.&lt;/h1&gt;</code></p>
<p><code>&lt;a href=&quot;http://......&quot;&gt;This is a link.&lt;/a&gt;</code> 在href 属性中指定地址</p>
<p><code>&lt;img src=&quot;aaa.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt;</code> 图像的名称和尺寸是以属性的形式提供的。注意，这是一个空元素void element, 即使是空元素，也需要加结尾/&gt;</p>
</li>
<li><p>HTML 元素</p>
<p>HTML元素是从开始标签到结束标签里所有的代码。某些元素有空内容。大多数元素可以拥有属性。元素之间可以嵌套。</p>
<p>虽然对大小写不敏感，但推荐使用小写标签，然后每一个元素都要关闭，哪怕是空元素 <code>&lt;br /&gt;</code> <code>&lt;img src=&quot;aaa.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt;</code></p>
</li>
<li><p>HTML 属性</p>
<p>属性可以为元素提供更多的信息。总是以名称=值（name=“value”）形式出现。总是在开始标签里规定。</p>
<p>多个属性之间空格间隔，属性名称后紧跟=，属性值<strong>一定</strong>要使用“”包围（不然浏览器会误解）</p>
<p>虽然对大小写不敏感，但推荐使用小写。始终为属性加引号，单双引号都可以，但里面出现双引号，外面就要使用单引号。</p>
<p>布尔属性：属性值与属性名称相等，如disabled</p>
<p><a href="https://www.w3school.com.cn/html/html_attributes.asp" target="_blank" rel="noopener">例子</a>， <a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp" target="_blank" rel="noopener">全局属性参考手册</a></p>
</li>
<li><p>当显示页面时，浏览器会移除<em>源代码中</em>多余的空格和空行。<strong>所有连续的空格或空行都会被算作一个空格</strong>。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格</p>
<p>如果想保留这些换行和空格，可以使用<figure class="highlight plain"><figcaption><span>is    a paragraph.```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. 超级链接:</span><br><span class="line"></span><br><span class="line">   基本格式</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;a href=&quot;url&quot;&gt;Link text&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>​        target：在新窗口打开网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.w3school.com.cn/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Visit W3School!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        name：命名锚，读者看不见，但可以用它实现界面跳转。使用 id 属性来替代 name 属性，命名锚同样有效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"label"</span>&gt;</span>锚（显示在页面上的文本）<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，我们在同一个文档中创建指向该锚的链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#label"</span>&gt;</span>有用的提示<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您也可以在其他页面中创建指向该锚的链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.w3school.com.cn/html/html_links.asp#tips"</span>&gt;</span>有用的提示<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p><strong>当同一个 HTML 元素被不止一个样式定义时，会使用哪个样式呢？</strong></p>
<p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。</p>
<ol>
<li>浏览器缺省设置</li>
<li>外部样式表</li>
<li>内部样式表（位于 <head><meta name="generator" content="Hexo 3.9.0"> 标签内部）</head></li>
<li>内联样式（在 HTML 元素内部）</li>
</ol>
<p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明：<head><meta name="generator" content="Hexo 3.9.0"> 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</head></p>
</li>
<li><p>块级元素(block-level)和内联元素(inline)</p>
<p>Block-level element: will appear on a new line eg. </p>
<p>Inline element: are contained within block-level elements and surround only small parts of the document’s content</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>first<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>second<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>third<span class="tag">&lt;/<span class="name">em</span>&gt;</span> inline element</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>fourth<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>fifth<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>sixth<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  block element</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>元数据 <meta>元素</li>
</ol>
<p>元数据就是描述数据的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> 字符集</span><br></pre></td></tr></table></figure>

<p>utf-8包含了任何人类语言的大部分字符，没有出现在字符集里的字符会显示乱码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"Chris Mills"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"The MDN Learning Area aims to provide</span></span></span><br><span class="line"><span class="tag"><span class="string">complete beginners to the Web with all they need to know to get</span></span></span><br><span class="line"><span class="tag"><span class="string">started with developing web sites and applications."</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定包含关于页面内容的关键字的页面内容的描述是很有用的，因为它可能或让你的页面在搜索引擎的相关的搜索出现得更多，SEO搜索引擎优化。description就是出现在搜索网页结果下面的一段描述。</p>
<p>许多meta元素不再使用了，比如key — 提供关键词给搜索引擎，根据不同的搜索词，查找到相关的网站 — 已经被搜索引擎忽略了， 因为作弊者填充了大量关键词到keyword， 错误地引导搜索结果。</p>
<p>其他类型元数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image"</span> <span class="attr">content</span>=<span class="string">"https://developer.cdn.mozilla.net/static/img/opengraph-logo.dc4e08e2f6af.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:description"</span> <span class="attr">content</span>=<span class="string">"The Mozilla Developer Network (MDN) provides</span></span></span><br><span class="line"><span class="tag"><span class="string">information about Open Web technologies including HTML, CSS, and APIs for both Web sites</span></span></span><br><span class="line"><span class="tag"><span class="string">and HTML5 Apps. It also documents Mozilla products, like Firefox OS."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:title"</span> <span class="attr">content</span>=<span class="string">"Mozilla Developer Network"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在facebook（不仅仅，linkedin也支持）上链接网页时，所展示的图片，描述和标题</p>
<ol start="12">
<li><p>在HTML里应用CSS和JavaScript</p>
<p>HTML：网站内容</p>
<p>CSS：网站样式</p>
<p>JavaScript：网站的互动</p>
<ol>
<li>link元素经常位于文档的头部。这个link元素有2个属性，rel=”stylesheet”表明这是文档的样式表，而 href包含了样式表文件的路径</li>
<li>Script 元素放在文档末尾，这样可以确保在加载脚本之前浏览器已经解析了HTML内容（如果脚本加载某个不存在的元素，浏览器会报错）</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"my-css-file.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"my-js-file.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>61. Rotate List</title>
    <url>/61.%20Rotate%20List.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>使用start每次记录linked list的开头，用while语句每次寻找linked list的尾部前一个数（不找尾部是因为linked list只知道next node，所以在尾部时，我们不知道尾部的上一个node是什么），然后target，即尾部node，是我们移动的目标，改变其指向到linked list开头，然后cur 指向None（cur变成尾部node了），最后更新start pointer指向新的开头，即target。重复上述步骤k次。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: </span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        start = ListNode(<span class="literal">None</span>)</span><br><span class="line">        start.next = head  <span class="comment"># using start to record the head of linked list</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            cur = start.next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> cur.next.next:  <span class="comment"># using this part to find the previous node of end node</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># the end node, which is also the target we want to pop to the head</span></span><br><span class="line">            target = cur.next </span><br><span class="line">            </span><br><span class="line">            cur.next = <span class="literal">None</span> <span class="comment"># the previous should be the new end node</span></span><br><span class="line">            target.next = start.next <span class="comment"># old end node will be the head of list</span></span><br><span class="line">            start.next = target <span class="comment"># renew the start pointer</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start.next <span class="comment"># return the linked list, exclude start pointer</span></span><br></pre></td></tr></table></figure>

<p>很明显，算法的时间复杂度是O(k*n) n is the length of linked list. 乍看之下不算高，但是遇到k很大的情况肯定会超时，而且很明显有可以提升速度的地方。比如while语句寻找end node。</p>
<p>所以不如先遍历一遍知道linked list长度，然后k 用长度取模（k&gt;length 会多转一圈）。然后cur遍历到需要cut的位置，cut后面的linked list block要被放到最前面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k : <span class="keyword">return</span> head </span><br><span class="line">    </span><br><span class="line">        <span class="comment"># first we need know the length of linked list</span></span><br><span class="line">        cur = head</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">            </span><br><span class="line">        k = k % length <span class="comment"># simplify k</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k : <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = head <span class="comment"># here cur was used to get the the previous node of NewHead</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length - k - <span class="number">1</span>): <span class="comment"># reach to the cut position</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        </span><br><span class="line">        newHead = cur.next <span class="comment"># after cut is the linked list block which should be placed on in front</span></span><br><span class="line">        cur.next = <span class="literal">None</span> <span class="comment"># the node before cut will be the new end</span></span><br><span class="line">        </span><br><span class="line">        cur = newHead <span class="comment"># here cur was used to get the end node of linked list block</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = head <span class="comment"># link old head with linked list block</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead <span class="comment"># return the new head</span></span><br></pre></td></tr></table></figure>

<p>O(2n) n is the length of linked list</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>42. Trapping Rain Water</title>
    <url>/42.%20Trapping%20Rain%20Water.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hard</p>
<p>424078FavoriteShare</p>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"><br> The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]</p>
<p><strong>Output:</strong> 6</p>
 <a id="more"></a>

<ol>
<li>横向计算</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(max(nums), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            idx = [i <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> x &gt;= c ]</span><br><span class="line">            <span class="keyword">if</span> len(idx) &gt; <span class="number">1</span>:</span><br><span class="line">                res += (idx[<span class="number">-1</span>] - idx[<span class="number">0</span>] - len(idx) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(m*n)长✖️高</p>
<ol start="2">
<li>纵向计算</li>
</ol>
<p>求每一列的水，我们只需要关注当前列高度，以及左边最高的墙，右边最高的墙就够了，在根据木桶效应，从左右最高墙里选择一个最矮的墙，和当前列计算高度差就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)<span class="number">-1</span>):</span><br><span class="line">            l = max(nums[:i])</span><br><span class="line">            r = max(nums[i+<span class="number">1</span>:])</span><br><span class="line">            dif = min(l, r)</span><br><span class="line">            <span class="keyword">if</span> dif &gt; nums[i]:</span><br><span class="line">                res += dif-nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n²），遍历每一列需要 n，找出左边最高和右边最高的墙加起来刚好又是一个 n，所以是 n²。</p>
<p>空间复杂度：O（1）。</p>
<p>由此发现时间复杂度极高，有没有合适的方法解决呢？那就需要用到下面的DP改良方法了。</p>
<ol start="3">
<li><p>DP改良版</p>
<p>同样是去寻找左边最高的墙，右边最高的墙，我们不用每到达新的一列，就重复的向前向后遍历，而是先遍历用DP array存储好，计算时候拿来直接用就行了。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        R = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            L[i] = max(L[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            R[i] = max(R[i+<span class="number">1</span>], nums[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            dif = min(L[i], R[i])</span><br><span class="line">            <span class="keyword">if</span> dif &gt; nums[i]:</span><br><span class="line">                res += dif - nums[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n），只使用了3个for循环，两个分别用来从左到右，从右到左计算目前已知最高的墙。</p>
<p>空间复杂度：O（n）。有得必有失，需要用两个和输入一样大小的list存储dp结果</p>
<ol start="4">
<li><p>stack</p>
<p>详细参考<a href="https://www.cnblogs.com/grandyang/p/4402392.html，主旨是维护一个单调递减栈。" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4402392.html，主旨是维护一个单调递减栈。</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = [] <span class="comment"># using monotone stack (decreasing)</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="comment"># if the top element of stack is highter than cur element, add it </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> nums[stack[<span class="number">-1</span>]] &gt;= nums[i]: </span><br><span class="line">                stack.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                puddle = nums[stack.pop()]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack: <span class="keyword">continue</span></span><br><span class="line">                res += (min(nums[i], nums[stack[<span class="number">-1</span>]]) - puddle) * (i - stack[<span class="number">-1</span>] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>84. Largest Rectangle in Histogram</title>
    <url>/84.%20Largest%20Rectangle%20in%20Histogram.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Hard</p>
<p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" alt="img"><br>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt="img"><br>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>Brute force</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, h: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> range(len(h)):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(cur,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> h[l] &lt; h[cur]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(cur, len(h)):</span><br><span class="line">                <span class="keyword">if</span> h[r] &lt; h[cur]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            area = h[cur] * (r-l+<span class="number">1</span>)</span><br><span class="line">            ans = max(area, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O（n^2）</p>
<ol start="2">
<li><p>pruning optimize</p>
<p>参考<a href="https://www.cnblogs.com/grandyang/p/4322653.html" target="_blank" rel="noopener">这里</a>，跟原始的暴力方法差不多，用i代表选择数列的end，然后用j去向前便利，找到局部最小高度和最大面积，更新minHi，和res。但是这次进行了剪枝优化，不是每一个i都要重复计算一次，只计算有可能会有更大面积的高度，即题目里的2，6，3（因为他们都比后一列高），如果这一列比后一列低，那么这一列所能产生的最大高度，一定被后一列给计算到，所以就可以省略这一步。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> heights: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(heights) <span class="keyword">and</span> heights[i] &lt;= heights[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            minHi = heights[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                minHi = min(minHi, heights[j])</span><br><span class="line">                area = minHi * (i-j+<span class="number">1</span>)</span><br><span class="line">                res = max(res, area)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>递增栈</p>
<p><a href="https://www.cnblogs.com/grandyang/p/4322653.html" target="_blank" rel="noopener">这里</a>讲解得很好了。首先对于栈的选择，为什么使用递增栈而不是递减栈，因为为了解决题目，我们需要同时记录<strong>连续的长度</strong>，<strong>最矮的矩形</strong>。当使用单调栈时，我们为了保证栈中的元素的单调性，我们会pop出一些元素，再也不加进来</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        heights.append(<span class="number">-1</span>)</span><br><span class="line">        cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; len(heights)):</span><br><span class="line">            <span class="comment"># print(stack, res, i, cur)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> stack <span class="keyword">or</span> heights[stack[<span class="number">-1</span>]] &lt; heights[i]):</span><br><span class="line">                stack.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack: </span><br><span class="line">                    curArea = heights[cur] * (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="comment"># why not cur?</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    curArea = heights[cur] * i</span><br><span class="line">                res = max(res, curArea)</span><br><span class="line">            </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>Why not cur: 重点，之前就是这没搞明白，导致一直有bug。我之前一直认为stack[-1] + 1 == cur，然后发现大错特错，因为为了维护单调栈，有些元素是会pop出去，然后再也不加进来的所以cur和stack[-1]并不是连续的，所以说 stack[-1] + 1 不一定等于 cur， stack[-1] + 1保证了被pop出去的元素也会参与长度的计算，不过这些话可能只有犯过和我一样错的人才能理解吧！总而言之，还是自己对单调栈理解不熟，才会有这样bug。</p>
<p>时间复杂度：O(n)，因为对于每个柱子只会经历入栈出栈，所以最多 2n 次</p>
<p>空间复杂度：O(n)，栈的大小</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1114. Print in Order</title>
    <url>/1114.%20Print%20in%20Order.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Easy</p>
<p>Suppose we have a class:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">  public void first() &#123; print(&quot;first&quot;); &#125;</span><br><span class="line">  public void second() &#123; print(&quot;second&quot;); &#125;</span><br><span class="line">  public void third() &#123; print(&quot;third&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The same instance of <code>Foo</code> will be passed to three different threads. Thread A will call <code>first()</code>, thread B will call <code>second()</code>, and thread C will call <code>third()</code>. Design a mechanism and modify the program to ensure that <code>second()</code> is executed after <code>first()</code>, and <code>third()</code> is executed after <code>second()</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>多线程 multithread: different thread share the same storage, may appears the situation that they address the same global variable at the same time, so we don’t know which one is first. and the result may different during different running.</p>
<ol>
<li>using barrier</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Barrier</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.first_barrier = Barrier(<span class="number">2</span>)</span><br><span class="line">        self.second_barrier = Barrier(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line">        <span class="comment"># printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond()</span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line">        <span class="comment"># printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>using locks</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.locks = (Lock(),Lock())</span><br><span class="line">        self.locks[<span class="number">0</span>].acquire()</span><br><span class="line">        self.locks[<span class="number">1</span>].acquire()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.locks[<span class="number">0</span>].release()      </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.locks[<span class="number">0</span>]:</span><br><span class="line">            <span class="comment"># printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">            printSecond()</span><br><span class="line">            self.locks[<span class="number">1</span>].release()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.locks[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>155. Min Stack</title>
    <url>/155.%20Min%20Stack.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>虽然这是一道简单题，但是并不简单。</p>
<ol>
<li>python</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        res = self.stack[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.stack)):</span><br><span class="line">            res = min(res, self.stack[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这是最容易实现和想的一个方法，但是当stack存入太多item的时候，getMin将变得十分耗时，起码是O(n)的时间复杂度。如何解决？我们不如换个思路，当加入item的时候就记录下最小值。这里用到了动态规划的思想，最小值是，前一个数的最小值和当前数做比较来获得的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append((x, min(x, self.getMin())))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minNum = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.minNum = min(x, self.minNum)</span><br><span class="line">        self.stack.append([x, self.minNum])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># after poping, we need to update minNum</span></span><br><span class="line">        <span class="keyword">if</span> self.stack: self.minNum = self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>: self.minNum = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack: </span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>和上面的异曲同工，但是没有调用内部函数</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/215.%20Kth%20Largest%20Element%20in%20an%20Array.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Medium</p>
<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<a id="more"></a>

<ol>
<li><p>using Priority Queue</p>
<p>Notice: priority queue is increase order</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pq = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            pq.put(-i)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            pq.get()</span><br><span class="line">        <span class="keyword">return</span> -pq.get()</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(n log n) insert a element O(log n)</p>
<p>Space complexity: O(n)</p>
<p><strong>我们也可以发现这题本质其实是考察排序，所以有如下一些排序方法</strong></p>
<p><strong>This question ask you to find the kth largest element in the list appearly, but actually it wants you to use different sorted algorithm</strong></p>
<ol start="2">
<li><p>Sorted (off the shelf)</p>
<p><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">Timsort algoritm</a>, 结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)[::<span class="number">-1</span>][k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(n log n) because using Timsort</p>
<p><img src="https://pic1.zhimg.com/v2-497ffb4a451d35d331c65036686b8809_r.jpg" alt="preview"></p>
<p>Space complexity: O(n)</p>
<ol start="3">
<li>Bubble sorted</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">          <span class="comment"># keep moving large element to the end</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)-i<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums) - k]</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(n k) </p>
<p>Space complexity: O(n)</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU Cache</title>
    <url>/146.%20LRU%20Cache.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\146. LRU Cache</p>
<p>Medium</p>
<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<a id="more"></a>

<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure>

<ol>
<li>List + dic</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.list = []</span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.list:</span><br><span class="line">            self.list.remove(key)</span><br><span class="line">            self.list.append(key)</span><br><span class="line">            <span class="keyword">return</span> self.dic[key]</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.dic[key] = value</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.list:</span><br><span class="line">            self.list.remove(key)</span><br><span class="line">        self.list.append(key)</span><br><span class="line">        <span class="keyword">if</span> len(self.list) &gt; self.capacity:</span><br><span class="line">            delKey = self.list.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">del</span> self.dic[delKey]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>double linked list + dict</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = v</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.dic = dict()</span><br><span class="line">        self.head = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            n = self.dic[key]</span><br><span class="line">            self._remove(n)</span><br><span class="line">            self._add(n)</span><br><span class="line">            <span class="keyword">return</span> n.val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self._remove(self.dic[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self._add(n)</span><br><span class="line">        self.dic[key] = n</span><br><span class="line">        <span class="keyword">if</span> len(self.dic) &gt; self.capacity:</span><br><span class="line">            n = self.head.next</span><br><span class="line">            self._remove(n)</span><br><span class="line">            <span class="keyword">del</span> self.dic[n.key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.next</span><br><span class="line">        p.next = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        p = self.tail.prev</span><br><span class="line">        p.next = node</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">        node.prev = p</span><br><span class="line">        node.next = self.tail</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>344. Reverse String</title>
    <url>/344.%20Reverse%20String.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\344. Reverse String</p>
<p>Easy</p>
<p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p>
<p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank" rel="noopener">printable ascii characters</a>.</p>
 <a id="more"></a>

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<ol>
<li>two pointer (one while loop)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi):</span><br><span class="line">            s[lo], s[hi] = s[hi], s[lo]</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">            hi -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>one for loop</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) // <span class="number">2</span>):</span><br><span class="line">          	s[i], s[-i<span class="number">-1</span>] = s[-i<span class="number">-1</span>], s[i]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/14.%20Longest%20Common%20Prefix.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\14. Longest Common Prefix</p>
<p>Easy</p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li>终极改良版</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    </span><br><span class="line">        prefix = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">            prefix = self.same(prefix, s)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prefix: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">or</span> <span class="keyword">not</span> s2: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(s1), len(s2))):</span><br><span class="line">            <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">                <span class="keyword">return</span> s1[:i]</span><br><span class="line">        <span class="keyword">return</span> s1 <span class="keyword">if</span> len(s1) &lt;= len(s2) <span class="keyword">else</span> s2</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/3.%20Longest%20Substring%20Without%20Repeating%20Characters.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\3. Longest Substring Without Repeating Characters</p>
<p>Medium</p>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li><p>改良法</p>
<p>使用res 变量来记录最终答案 而不是一个list，节省空间</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        mem = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> mem:</span><br><span class="line">                mem.append(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res, len(mem))</span><br><span class="line">                mem = mem[mem.index(ch)+<span class="number">1</span>:]</span><br><span class="line">                mem.append(ch)</span><br><span class="line">        <span class="keyword">return</span> max(res, len(mem))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        mem = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> mem.keys():</span><br><span class="line">                start = max(start, mem[c] + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            mem[c] = i</span><br><span class="line">            ans = max(ans, i-start+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>380. Insert Delete GetRandom O(1)</title>
    <url>/380.%20Insert%20Delete%20GetRandom%20O(1).html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\380. Insert Delete GetRandom O(1)</p>
<p>Medium</p>
<p>1501109Share</p>
<p>Design a data structure that supports all following operations in <em>average</em> <strong>O(1)</strong> time.</p>
<ol>
<li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>
<li><code>remove(val)</code>: Removes an item val from the set if present.</li>
<li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <strong>same probability</strong> of being returned.</li>
</ol>
<a id="more"></a>

<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>

<p>python list，set，dictionary时间复杂度<a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="noopener">参考</a>。这题重点在于如何实现O(1)的时间，因为在python list 里，remove 和 insert 都是O(n)的时间复杂度。题目要求 insert 和 remove 能够判断 val 在不在里面，list 的 in 也是O(n)。 所以我们就想到了用hash map，或者说是set。</p>
<p>然后我就想到下面的代码，但是虽然满足了remove, add, in都是O(1)，但是缺不能满足getRandom(self)，因为list()需要的时间是O(n).</p>
<p><strong>错误示范：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.mem = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.mem: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mem.add(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.mem:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.mem.remove(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.List = list(self.mem) <span class="comment"># attention: the time complexity is O(n)</span></span><br><span class="line">        <span class="keyword">return</span> (random.choice(self.List))</span><br></pre></td></tr></table></figure>

<p>所以，思来想去还是需要一个list来存储val。但是remove如何在O(1)时间删除list里的东西又成了问题。这时候就参考了<a href="https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/85397/Simple-solution-in-Python" target="_blank" rel="noopener">这个</a>方法，简而言之，记录每一个val在list里的位置，然后将此位置上的val替换成末尾的数，再在dict里更新末位数位置（当前val的位置）把末尾的数pop出去就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.listMem = []</span><br><span class="line">        self.dicMem = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.dicMem:</span><br><span class="line">            self.listMem.append(val)</span><br><span class="line">            self.dicMem[val] = len(self.listMem) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dicMem:</span><br><span class="line">            pos, last = self.dicMem[val], self.listMem[<span class="number">-1</span>]</span><br><span class="line">            self.dicMem[last], self.listMem[pos] = pos, last</span><br><span class="line">            <span class="keyword">del</span> self.dicMem[val]; self.listMem.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.listMem)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>1131. Maximum of Absolute Value Expression</title>
    <url>/1131.%20Maximum%20of%20Absolute%20Value%20Expression.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>\1131. Maximum of Absolute Value Expression</p>
<p>Medium</p>
<p>Given two arrays of integers with equal lengths, return the maximum value of:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</span><br></pre></td></tr></table></figure>

<p>where the maximum is taken over all <code>0 &lt;= i, j &lt; arr1.length</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]</span><br><span class="line">Output: 13</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]</span><br><span class="line">Output: 20</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= arr1.length == arr2.length &lt;= 40000</code></li>
<li><code>-10^6 &lt;= arr1[i], arr2[i] &lt;= 10^6</code></li>
</ul>
<a id="more"></a>

<ol>
<li>Brute force</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAbsValExpr</span><span class="params">(self, arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr1)-i):</span><br><span class="line">                cur = abs(arr1[j] - arr1[j+i]) + abs(arr2[j] - arr2[j+i]) + i</span><br><span class="line">                ans = max(ans, cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(n^2)</p>
<p>Space complexity: O(1)</p>
<ol start="2">
<li><p>对于公式的简化形成四种case</p>
<p><a href="https://www.cnblogs.com/seyjs/p/11302096.html" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAbsValExpr</span><span class="params">(self, x: List[int], y: List[int])</span> -&gt; int:</span></span><br><span class="line">        maxCase1 = maxCase2 = maxCase3 = maxCase4 = -float(<span class="string">'inf'</span>)</span><br><span class="line">        minCase1 = minCase2 = minCase3 = minCase4 = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">            maxCase1 = max(maxCase1, x[i]+y[i]-i)</span><br><span class="line">            maxCase2 = max(maxCase2, x[i]-y[i]-i)</span><br><span class="line">            maxCase3 = max(maxCase3, -x[i]+y[i]-i)</span><br><span class="line">            maxCase4 = max(maxCase4, -x[i]-y[i]-i)</span><br><span class="line">            minCase1 = min(minCase1, x[i]+y[i]-i)</span><br><span class="line">            minCase2 = min(minCase2, x[i]-y[i]-i)</span><br><span class="line">            minCase3 = min(minCase3, -x[i]+y[i]-i)</span><br><span class="line">            minCase4 = min(minCase4, -x[i]-y[i]-i)</span><br><span class="line">        <span class="keyword">return</span> max(maxCase1-minCase1, maxCase2-minCase2, maxCase3-minCase3, maxCase4-minCase4)</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/5cdnqIC.png" alt="image-20191128225218260"></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-107-Binary-Tree-Level-Order-Traversal</title>
    <url>/LeetCode-107-Binary-Tree-Level-Order-Traversal.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<a id="more"></a>

<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol>
<li>Use queue to do level traversal + deque.appendleft or list[ : : -1]  to realize bottom-up</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = deque()</span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span>(q):</span><br><span class="line">            temp = []</span><br><span class="line">            l = len(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                temp.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: q.append(cur.right)</span><br><span class="line">            res.appendleft(temp) <span class="comment"># appendleft to realize bottom up</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span>(q):</span><br><span class="line">            temp = []</span><br><span class="line">            l = len(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(l):</span><br><span class="line">                cur = q.pop(<span class="number">0</span>)</span><br><span class="line">                temp.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left: q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: q.append(cur.right)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>] <span class="comment"># list[::-1]</span></span><br></pre></td></tr></table></figure>

<p>Time complexity is O(n)</p>
<ol start="2">
<li>DFS + record level</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(res, <span class="number">0</span>, root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, res, level, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; (level + <span class="number">1</span>):</span><br><span class="line">                res.insert(<span class="number">0</span>, [])  <span class="comment"># notice: here insert is O(n)</span></span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            self.dfs(res, level + <span class="number">1</span>, node.left)</span><br><span class="line">            self.dfs(res, level + <span class="number">1</span>, node.right)</span><br></pre></td></tr></table></figure>

<p>So time complexity is O(n^2)</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP学习笔记</title>
    <url>/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>教材：图解HTTP</p>
<p>分享一下自己做的笔记。share my note about studying HTTP</p>
<a id="more"></a>

<ol>
<li><p>TCP/IP协议：</p>
<p>四层：应用层，传输层，网络层，数据链路层。</p>
<p>应用层 application layer：FTP, DNS, HTTP</p>
<p>传输层 transport layer：TCP, UDP</p>
<p>网络层 network layer ：处理数据包 Packet，路由选择 routing</p>
<p>数据链路层 data link layer: hardware part, control OS, network interface card.</p>
</li>
<li><p>Encapsulate :</p>
</li>
</ol>
<p><img src="https://imgur.com/D3PXQ1p.jpg" alt="Imgur"></p>
<ol start="3">
<li><p>TCP/IP 协议介绍：</p>
<p>HTTP: generate requirement message, address requirement message</p>
<p>TCP: Three-way handshaking, ACK, SYN.</p>
<p>​         Message —-split into—-&gt; segment </p>
<p>​         several segments —–re-organize—-&gt; Message</p>
<p>IP: routing </p>
<p>ARP: address resolution protocol, IP address -&gt; MAC address</p>
<p>DNS: domain name system. Domain name -&gt; IP address</p>
</li>
<li><p>URI &amp; URL</p>
<p>URI: Uniform (统一的格式) Resource (各种资源，图片，文字等，或是整个集合) Identifier (标识资源)</p>
<p>URL: Uniform Resource Locator(标识资源地点)</p>
<p>URL $\subseteq$ URI</p>
</li>
<li><p>HTTP是不保存状态的协议 (stateless): 不保存过往请求和响应，不记录client</p>
<p>简单高效，但是存在问题：用户登陆一个购物网站，你需要记录用户的登录状态，哪怕切换到别的网页。</p>
<p>解决方法: 1. 在报文中加入参数管理登录状态。2. <strong>cookie</strong></p>
</li>
</ol>
<ol start="6">
<li><p>HTTP 协议支持的一些方法</p>
<p><img src="https://imgur.com/1TV03lX.png" alt="image-20191104162543231"></p>
</li>
<li><p>多部分对象集合</p>
<p>MIME (multipurpose Internet Mail Extension) 让我们在发送邮件时，可以添加文件，图片等附件</p>
<p>HTTP也有相似的功能。</p>
</li>
<li><p>获取部分的范围请求</p>
<p>当下载中断时，需要从中断部分重新开始下载，而不是全部在发一遍，这时候就需要用到 获取部分的范围请求 (Range request)。用到首部字段 range 标记 byte 范围</p>
</li>
<li><p>内容协商 content negotiation</p>
<p>根据协商返回最适合的内容。如根据浏览器语言设置返回中文界面还是英文界面。</p>
</li>
<li><p>返回结果里的HTTP状态码</p>
<p><img src="https://imgur.com/9P4CRtW.png" alt="image-20191104165812216"></p>
<p>可能一提专业名称大家都没反应过来这是啥，但是大家一定知道404 Not Found，这就是状态码的一种，标识服务器上找不到资源或者是服务器无理由拒绝请求。</p>
</li>
<li><p>一台web服务器可以搭建多个有独立域名的web网站</p>
<p>因为在物理层面上只有一台服务器，所以表面域名不同，但是IP地址是相同的。所以在发送HTTP请求时，需要在host里完整指明主机名或者域名的URI</p>
</li>
<li><p>数据转发程序：代理，网关，隧道</p>
<p>代理：</p>
<p>1）是否使用缓存：缓存代理 Caching Proxy，接收第一次资源请求时，将资源副本（缓存）保存在代理服务器上。如果下次还有相同请求，直接发送副本，就不用从源服务器上再次获取资源了。</p>
<p>2）是否修改报文：透明代理 Transparent Proxy，不对报文进行修改。</p>
<p>网关：</p>
<p>和代理很像，可以使用网关提高通行安全（在客户端和网关的通信间进行加密）</p>
<p>隧道：<br>本身不会解析HTTP请求，但是会使用SSH等加密手段确保通信等安全。</p>
</li>
<li><p>缓存</p>
<p>可以有效减少对源服务器资源请求的次数。</p>
<p>有效期：<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">LRU Cache</a></p>
<p>位置：缓存服务器，客户端（临时网络文件）</p>
</li>
<li><p>HTTP首部</p>
<p>HTTP/1.1规范47种首部字段，共四类：general header fields, request header fields, response header fields, Entity header fields.</p>
<p>非规范首部字段有: cookie, set-cookie, content-deposition</p>
<p>general header fields: Both of requirement message and response message will use this part</p>
<p>a. cache-control: </p>
</li>
<li><p>为cookie服务的首部字段：</p>
<p>Set-cookie: 开始状态管理所使用的cookie信息</p>
<p>cookie: 服务器接收到的cookie信息</p>
</li>
<li><p>其他首部字段：</p>
<p>X-Frame-Options: 控制网站内容在其他网站frame标签内显示的问题，防止点击劫持</p>
<p>X-XSS-Protection: 针对跨站脚步攻击(XSS)的一种策略</p>
<p>DNT (do not track)：拒绝个人信息被收集，防止精准投放</p>
<p>P3P: 保护用户隐私。</p>
</li>
<li><p>HTTP 的缺点</p>
<ol>
<li><p>不验证用户身份：可能遭遇伪装 lack of authentication</p>
<p>解决方法：查明对手证书SSL</p>
</li>
<li><p>使用明文传输：可能会被窃取 Clear (plain) text transmission</p>
<p>使用抓包工具 Wireshark就可以进行解析</p>
<p>解决方法：通信加密（Secure Socket Layer + Transport Layer Security），内容加密</p>
</li>
<li><p>无法证明报文完整性：被篡改也不知道 </p>
<p>解决方法MD5和SHA-1等散列值校验方法</p>
<p>使用数字签名 Digital Signature</p>
</li>
</ol>
</li>
<li><p>HTTPS = HTTP + 加密 + 认证 + 完整性保护</p>
<p>HTTPS只是将HTTP的通信接口用SSL和TLS协议代替了</p>
<p><img src="https://imgur.com/C3vantT.png" alt="image-20191104205811275"></p>
</li>
<li><p>SSL的加密方式 公开密钥加密（public key cryptography）</p>
<p>加密方式是公开的，密钥是保密的，如果使用一把密钥进行加密时，仍然有密钥被窃取的风险</p>
<p>对称密钥Symmetric-key algorithm</p>
<p>所以使用两把密钥进行公开密钥加密：使用一对非对称密钥，一把叫private key，一把叫public key</p>
<p>HTTPS采用两种方式的混合加密</p>
</li>
<li><p>验证访问用户的身份 authentication</p>
<p>你说你是ueno并不能代表你就是ueno，所以就需要核对一些只有访问者自己才知道的信息（取快递时问你电话号码）。</p>
<p>HTTP使用的认证方式：</p>
<ol>
<li><p>Basic认证：<a href="https://juejin.im/entry/5ac175baf265da239e4e3999" target="_blank" rel="noopener">here</a></p>
<p>过程：客户端发送访问请求 –&gt; 服务器返回401要求身份验证 –&gt; 客户端发送用户名：密码以base64编码处理 –&gt; 服务器返回成功200</p>
<p>缺点：1. 因为base64不是加密编码，所以还是会有信息被盗的风险。2. 无法实现认证注销</p>
</li>
<li><p>DIGEST认证：采用质询码nonce进行认证。nonce随机产生</p>
</li>
<li><p>SSL客户端验证：使用客户端证书client certificate 进行的验证</p>
<p>过程：事先分发证书，客户端发送访问请求 –&gt; 服务器发送 certificate request报文 –&gt; 客户端发送 client certificate –&gt; 服务器验证</p>
</li>
<li><p>基于表单 credential 的认证：各种网站的登录界面</p>
</li>
</ol>
</li>
<li><p>Session and Cookie</p>
<p>过程：客户端发送用户ID和密码 –&gt; 服务器身份验证，然后将 Session ID 和用户认证状态绑定，向客户端返回响应时会把 Session ID 放在 Set Cookie里 —&gt; 客户端接收后，保存Cookie到本地，里面的Session ID也就自动保存了，下次就自动发送给服务器，然后服务器端就可以验证 Session ID</p>
</li>
<li><p>密码加盐 salt（减少密码特征，防止用密码特征库破解），再hash，可以用来保存用户名和密码。</p>
</li>
<li><p>Ajax (Asynchronous JavaScript and XML) 利用JavaScript and DOM 实现局部网页更新</p>
<p>why：Facebook的内容更新，不可能每次都更新整个页面。所以需要Ajax进行局部更新</p>
<p><img src="https://imgur.com/idjqEtS.jpg" alt="Imgur"></p>
</li>
<li><p>Comet 通过延迟应答，实现服务器端向客户端发送更新。可以实现实时更新，但是为了维持连接会消耗更多资源<img src="https://imgur.com/812yZOs.jpg" alt="image-20191105122357111" style="zoom:40%;"></p>
</li>
<li><p>SPDY协议</p>
<p>为了在协议级别消除HTTP的瓶颈，在TCP/IP的应用层与运输层之间加入会话层进行运作</p>
<img src="https://imgur.com/bEOH1BZ.jpg" alt="image-20191105122619686" style="zoom:40%;">
</li>
<li><p>使用浏览器进行全双工通信的WebSocket</p>
<p>可以调用WebSocket API实现协议下的全双工通信。</p>
</li>
<li><p>HTML (HyperText Markup Language)</p>
<p>CSS (Cascading Style Sheets)</p>
<p>DOM (Document Object Model)</p>
<p>CGI (Common Gateway Interface)</p>
<p>XML (eXtensible Markup Language): 用标签分割而成的树形结构，更容易对数据进行读取</p>
<p>JSON (JavaScript Object Notation): </p>
</li>
</ol>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>DP动态规划的一些想法 + Leetcode120,213 Solution</title>
    <url>/DP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20+%20Leetcode120,213%20Solution.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>首先这是一篇对于动态规划进一步归纳总结的文章，所以一些对于动态规划的基本概念我就不介绍了。如果还有对动态规划不太了解的地方，可以看看<a href="https://www.zhihu.com/question/23995189" target="_blank" rel="noopener">这里</a>。</p>
<p><strong>dp的本质是：当前的分析要建立在过往分析的基础上。所以过往分析一定要做到两点，一个是全，一个是优。</strong></p>
<p>对于全：如果对过往分析的成果保存不全（比如：用新数据覆盖了，或者根本没存）那么信息的缺失一定会导致结果的局限性，且不能达到最优。</p>
<p>对于优：即存下来的东西一定要是最优的结果。但是很多人在找动态转移方程时就会犯一个错误，为了优而放弃了全，用最优的新数据覆盖了后面可能还会需要用到的数据。在我看来这是DP用不好的重要原因之一。</p>
<p>所以为了兼顾优和全，储存DP结果的这个list的一定要构造好。把需要做到全的结果，当成需要存储的一个维度，这样一般就可以解决上面这个问题。</p>
<a id="more"></a>

<p>不如让我举个🌰：</p>
<p>Leetcode 120</p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p>
<p><strong>Note:</strong></p>
<p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>
<ol>
<li><p>DP</p>
<p>一看就是用动态规划，但是如何构造DP List呢？即每个$dp[i][j]$应该存点什么。肯定是最短路径的值，但是是什么到什么的最短路径呢？我一开始的想法就犯了上面的错误，我考虑的是用一维array，每个$dp[i]$存储每层最短路径的值，$dp[0] = 2，dp[1] = 5，dp[2] = 10，dp[3] = 11$这样肯定是不对的，每个点的信息并没有存储全，从而也无法根据过往的信息作出最优的选择。</p>
<p>然后我又想到了从下往上走，但是使用一维array还是不够存储所有点的信息，因为只有遍历完所有点，存储每一个点的信息，才可以做出最优决策。所以这个array一定是二维的。</p>
<p>既然是二维的，那么$dp[i][j]$里每个i, j应该存些什么？考虑到dp的从小到大策略，再加上上面刚刚的想法，那么很容易就想到一个维度i代表每一层，另一个维度j代表一层的某一点，然后仍然可以借鉴刚刚从下往上走的想法。这样代码就出来了。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n<span class="number">-1</span>)]</span><br><span class="line">        dp.append(triangle[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = min(triangle[i][j] + dp[i+<span class="number">1</span>][j], triangle[i][j] + dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>同样的，有时候保留过多的信息，反而增加了空间复杂度。就可以做一些适当的优化。</strong></p>
<p>比如，这一题</p>
<ol start="213">
<li>House Robber II</li>
</ol>
<p>Medium</p>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),</span><br><span class="line">             because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>

<p>思路是动态规划，以及如何处理头尾部分。解决头位问题的办法就是跑两遍for循环，一遍一定偷头不偷尾，一遍一定偷尾不偷头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">3</span>: <span class="keyword">return</span> max(nums)</span><br><span class="line">        dp1 = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        dp2 = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            dp1[i] = max(nums[i]+dp1[i<span class="number">-2</span>], dp1[i<span class="number">-1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            dp2[i] = max(nums[i]+dp2[i<span class="number">-2</span>], dp2[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(dp1[<span class="number">-2</span>], dp2[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<p>改良前的dp算法使用两个dp list进行存储。但是我们也可以发现，对于每一个dp list，我们只用到了他最近的两个数字$dp[i-1],dp[i-2]$，所以完全可以不用list，而是两个variable就够了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">3</span>: <span class="keyword">return</span> max(nums)</span><br><span class="line">        cur = <span class="number">0</span> <span class="comment"># dp[i-1]</span></span><br><span class="line">        pre = <span class="number">0</span> <span class="comment"># dp[i-2]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            cur, pre = max(nums[i]+pre, cur), cur</span><br><span class="line">        temp = cur</span><br><span class="line">            </span><br><span class="line">        cur = <span class="number">0</span> <span class="comment"># dp[i-1]</span></span><br><span class="line">        pre = <span class="number">0</span> <span class="comment"># dp[i-2]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            cur, pre = max(nums[i]+pre, cur), cur</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(temp, cur)</span><br></pre></td></tr></table></figure>

<p>⚠️以下两种写法并不等价</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre = cur</span><br><span class="line">cur = max(nums[i]+pre, cur)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur, pre = max(nums[i]+pre, cur), cur</span><br></pre></td></tr></table></figure>

<p><strong>同时，我们还要去减少一些无用的搜索。比如在寻找最优解的时候，可能会出现从头遍历一遍找到最优解，那不如直接每一步就存储好（或者就更新到）最优解，直接下一步就可以拿来用，这样就减少了搜索时间，同时也能减少存储时间。</strong>这样的过程一般适用于将原本的二维dp 矩阵简化到一维。这种简化不建议一次性实现，或者一看到题就想如何用一维dp array实现，因为：1. 一维到底是选取二维中的哪一个个维度？这一般只有实现过一次二维才会有想法。2. 遍历的顺序？哪怕只有一个维度，还是需要for 循环两遍的，那是先循环维度一还是维度二也是一个问题，其本质还是选取一维维度的问题。</p>
<p><strong>总之，动态规划问题应该是一个由全到简的过程，想要一步登天（用一维矩阵又快又好的实现）除非熟练度上来，不然不建议。</strong></p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithm算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客 SEO 优化 How to do SEO</title>
    <url>/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20SEO%20%E4%BC%98%E5%8C%96%20How%20to%20do%20SEO.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>中文详细参考<a href="https://chenhuichao.com/2018/04/13/seo/seo-search-engine-principle/" target="_blank" rel="noopener">这里</a>。英文<a href="https://moz.com/beginners-guide-to-seo/how-search-engines-operate" target="_blank" rel="noopener">here</a>。两篇文章写的很好，讲解也很详细，然后我也将从3W(What, Why, How)角度开始讲解。</p>
<a id="more"></a>

<h3 id="什么是SEO-What"><a href="#什么是SEO-What" class="headerlink" title="什么是SEO (What)"></a>什么是SEO (What)</h3><p>SEO 就是 <strong>Search Engine Optimization（搜索引擎优化）</strong>。通过对网站进行优化，来提高网站在搜索引擎中的排名，为网站带来更多的访问。简单来说就是优化自己的网站，让更多的人可以通过搜素引擎找到你。</p>
<h4 id="搜索引擎基本原理"><a href="#搜索引擎基本原理" class="headerlink" title="搜索引擎基本原理"></a>搜索引擎基本原理</h4><p>搜索引擎的工作过程大体可以分为三个阶段：</p>
<ol>
<li>爬行和抓取：搜索引擎通过跟踪链接访问网页、获得页面 HTML 代码并存入数据库。</li>
<li>预处理：索引程序对抓取来的页面数据进行文字提取、中文分词、索引等处理，以备排名程序调用。</li>
<li>排名：用户输入关键词后，排名程序调用索引数据库，计算相关性，然后按照一个的格式生成搜索结果页面。</li>
</ol>
<h3 id="如何SEO（How）"><a href="#如何SEO（How）" class="headerlink" title="如何SEO（How）"></a>如何SEO（How）</h3><h5 id="第一步：爬行和抓取"><a href="#第一步：爬行和抓取" class="headerlink" title="第一步：爬行和抓取"></a>第一步：爬行和抓取</h5><p>爬行和抓取是搜索引擎工作的第一步，完成<strong>数据收集</strong>的任务。</p>
<h5 id="spider蜘蛛"><a href="#spider蜘蛛" class="headerlink" title="spider蜘蛛"></a>spider蜘蛛</h5><p>搜索引擎用来爬行和抓取页面的程序叫做也就是我们熟知的蜘蛛（spider），也称为机器人（bot）。spider访问网站页面类似于普通用户使用的浏览器。spider 发出页面访问请求后，服务器返回 HTML 代码，spider 把收到的程序存入原始页面数据库。为了提高爬行和抓取速度，搜索引擎通常或多个spider并行爬行。</p>
<p>spider 访问任何一个网站时，都会先访问该网站根目录下的 rotbots.txt 文件。该文件可以告诉 spider 哪些文件或目录可以抓取或者禁止抓取。</p>
<h5 id="跟踪链接"><a href="#跟踪链接" class="headerlink" title="跟踪链接"></a>跟踪链接</h5><p>为了抓取网上尽可能多的页面，spider 会跟踪网页上的链接，从一个页面爬到下一个页面，就好像蜘蛛在蜘蛛网上爬行一样。<br>爬行遍历有两种策略：</p>
<ul>
<li>深度优先：spider 沿着页面的链接一直爬取，直到该页面没有其他链接为止</li>
<li>广度优先：spider 在一个页面发现多个链接，先把这页面的所有第一层链接都遍历完，再继续第二层链接遍历</li>
</ul>
<p>程序猿肯定对这两个遍历算法很熟悉啦。<br>理论上无论是深度优先还是广度优先，只要给 spider 足够的时间，总是能把互联网上所有的页面链接都爬取完。但实际情况并不是这样，由于各种资源的限制，搜索引擎也只是爬行和收录互联网的一部分。</p>
<p><strong>所以通常 spider 都是深度优先和广度优先混合使用</strong>。</p>
<h5 id="吸引蜘蛛"><a href="#吸引蜘蛛" class="headerlink" title="吸引蜘蛛"></a>吸引蜘蛛</h5><p>spider 是如何判断哪些页面重要？有几个影响因素：</p>
<ul>
<li>网站和页面权重。质量高，资格老的网站权重高。</li>
<li>页面更新度。更新频率高的网站权重高。</li>
<li>导入的链接。无论是外部链接还是内部链接，要被 spider 抓取，就必须要有导入链接进入页面。高质量的导入链接也经常使页面上的导出链接被爬行深度增加。</li>
<li>与首页的点击距离。一般来说，网站最高的权重就是首页，大部分外链都是指向首页，spider 访问最频繁的也是首页。所以离首页越近的页面，权重也相对更高，被 spider 爬行的机会也越大。</li>
</ul>
<h5 id="地址库"><a href="#地址库" class="headerlink" title="地址库"></a>地址库</h5><p>为了避免重复爬行和抓取网址，搜索引擎会建立一个地址库，记录已经被发现还没有抓取的页面，以及已经被抓取的页面。通过地址库会有几个来源：</p>
<ul>
<li>人工录入的种子网站</li>
<li>spider 爬取页面后，解析出网址，与地址库对比。如果不存在，则存入</li>
<li>站长通过搜索引擎网页提交网址（一般个人博客或网站都采用这种方式）</li>
</ul>
<h5 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h5><p>spider 抓取的数据存入原始页面数据库。其中的页面数据与用户浏览器得到的 HTML 是完全一样。</p>
<h5 id="爬行时的复制内容检测"><a href="#爬行时的复制内容检测" class="headerlink" title="爬行时的复制内容检测"></a>爬行时的复制内容检测</h5><p>检测并删除复制内容是在预处理的步骤处理掉。不过 spider 在爬行的时候也会进行一定程度的复制内容检测。权重低，而大量抄袭复制内容的网站，spider 可能就不再继续爬行了。这也是为什么说一个网站需要原创内容的原因。</p>
<h4 id="第二步：预处理"><a href="#第二步：预处理" class="headerlink" title="第二步：预处理"></a>第二步：预处理</h4><p>预处理即indexing，也就是搜索引擎是如何解读你网页的</p>
<p>预处理有时候也称为<strong>索引</strong>。因为索引是预处理中最主要的步骤。预处理有几个步骤：</p>
<ol>
<li>提取文字。搜索引擎会提取页面的可见文字以及特殊的包含文字信息的代码，如 Meta 标签、图片Alt属性、超链接锚文字等。</li>
<li>分词，不同的语言有不同的分词如中文分词，英文分词。对第一步提取的文字进行分词。不同的搜索引擎使用的分词算法不同，会有差异。</li>
<li>去停止词。无论中文还是英文，都会有一些频率高，对内容没有影响的词。如语气词、感叹词，介词、副词等。搜索引擎会在索引页面之前去除这些词。</li>
<li>消除噪声。绝大部分页面还有一部分内容对页面主题也没有贡献。比如版权声明文字，导航条等。以博客为例，每个页面几乎都会有的文章分类，历史导航等信息，都是与页面主题无关的。这些都是属于噪音，需要消除掉。</li>
<li>去重。同一篇文章经常会重复出现在不同的网站及同一个网站的不同网址，搜索引擎并不喜欢这种重复的内容，所以搜索引擎会对这部分内容进行去重。</li>
<li>正向索引。也称索引。经过前面文字提取、分词、消噪、去重后，搜索引擎得到的就是独特的，能反映页面主体内容，以词为单位的内容。接下来搜索引擎索引程序就可以提取关键词，按照分词程序划分好的词，把页面转换为一个关键词组成的集合，同时记录每一个关键词在页面上的出现频率、出现次数、格式、位置。然后把这些页面及关键词形成的结构存储进索引库。</li>
<li>倒排索引。正向索引还不能直接用于关键词排名。搜索引擎还需要把正向索引数据库重新构造为倒排索引，<strong>把文件对应到关键词的映射转换为关键词到文件映射</strong>。这样在搜索关键词的时候，排序程序就在倒排索引中定位到这个关键词，就可以马上找出这个关键词所有的文件。</li>
<li>链接关系计算。链接关系计算也是预处理重要的一部分。搜索引擎在抓取页面内容后，必须事前计算出：页面上有哪些链接指向哪些其他页面，每个页面都有哪些导入链接，链接使用了什么锚文字。<strong>这些复杂的链接指向关系形成了网站和页面的链接权重</strong>。Google PR 值就是这种链接关系的最主要体现之一。其他搜索引擎也都进行类似技术，虽然并不称为 PR。</li>
<li>特殊文件计算。除了 HTML 文件之外，搜索引擎还能爬取抓取和索引以文字为基础的多种文件类型，如 PDF，Word，PPT，TXT等。</li>
</ol>
<h4 id="第三步：排名"><a href="#第三步：排名" class="headerlink" title="第三步：排名"></a>第三步：排名</h4><p>到了这一步就是处理用户输入，然后根据用户输入的关键词，排名程序调用索引程序，计算排名，显示给用户。<br>这个过程也分为下面几个步骤：</p>
<h5 id="搜索词处理"><a href="#搜索词处理" class="headerlink" title="搜索词处理"></a>搜索词处理</h5><p>对用户输入的关键词进行分词、去停止词、指令处理等处理。</p>
<h5 id="文件匹配"><a href="#文件匹配" class="headerlink" title="文件匹配"></a>文件匹配</h5><p>根据关键词找出所有匹配关键字的文件。</p>
<h6 id="初始子集选择"><a href="#初始子集选择" class="headerlink" title="初始子集选择"></a>初始子集选择</h6><p>由于文件匹配阶段出来的文件数量巨大，不可能全部显示。因此需要根据页面权重计算出一个子集。</p>
<h5 id="相关性计算"><a href="#相关性计算" class="headerlink" title="相关性计算"></a>相关性计算</h5><p>选完子集后，就需要对子集中的页面进行相关性介绍。计算相关性是排名过程最重要的一步。<br>影响相关性主要因素有几点：</p>
<ol>
<li>关键词常用程度。越常用的词对搜索词的意义贡献越小。越不常用则越大。</li>
<li>词频与密度。在没有堆积关键词的情况下，页面的关键词出现次数越多，密度越高，则相关性也越大。不过该因素的重要程序越来越低了。</li>
<li>关键词的位置与形式。在前面索引提到的，页面的标题标签，黑体，H1都是比较重要的位置。</li>
<li>关键词的距离。切分后的关键词完整匹配地出现，说明与搜索匹配最相关。比如你搜索 <code>hexo博客SEO</code>，如果在页面上连续完整出现 <code>hexo博客SEO</code>，说明相关性最高。</li>
<li>链接分析与页面权重。除了页面本身的因素，页面之间的链接和权重关系也影响关键词的相关性，其中最重要的就是锚文字。页面有越多以搜索词为锚文字的导入链接，说明页面的相关性越强。</li>
</ol>
<h5 id="排名过滤及调整"><a href="#排名过滤及调整" class="headerlink" title="排名过滤及调整"></a>排名过滤及调整</h5><p>经过上面的步骤之后，已经得到大体的排名。之后搜索引擎可能还会有一些过滤算法，对排序进行轻微调整，其中最重要的过滤就是施加惩罚。一些有作弊的页面会被降低权重。</p>
<h5 id="排名显示"><a href="#排名显示" class="headerlink" title="排名显示"></a>排名显示</h5><p>所有排名确定后，排名程序就调用原始页面的标题、Description Meta 等信息显示在页面上。</p>
<h5 id="搜索缓存"><a href="#搜索缓存" class="headerlink" title="搜索缓存"></a>搜索缓存</h5><p>用户搜索很大一部分是由重复的。所以有一部分的搜索是会被缓存下来的。</p>
<h5 id="查询及点击日志"><a href="#查询及点击日志" class="headerlink" title="查询及点击日志"></a>查询及点击日志</h5><p>搜用用户的 IP 地址，搜索的关键词、搜索时间，以及点击了哪些结果页面，搜索引擎都记录形成日志，形成搜索统计日志。这些日志信息对搜索引擎判断搜索结果质量、调整搜索算法、预期搜索趋势等都有重要意义。</p>
<p>通过上面的三个步骤，你就能对搜索引擎的工作原理有了更深的理解。这对接下来要写的站内优化内容及博客优化实践能更好的理解。</p>
<p>Reference is <a href="https://chenhuichao.com/2018/04/13/seo/seo-search-engine-principle/" target="_blank" rel="noopener">here</a>, I will explain it from What, Why, How</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>What is SEO? SEO is <strong>Search Engine Optimization</strong>, by optimizing the website to improve the ranking of the website in the search engine, bring more access to the website.</p>
<h4 id="Search-engine-basics"><a href="#Search-engine-basics" class="headerlink" title="Search engine basics"></a>Search engine basics</h4><p>Search engines are answer machines. They scour billions of pieces of content and evaluate thousands of factors to determine which content is most likely to answer your query.</p>
<p>Search engines do all of this by discovering and cataloguing all available content on the Internet (web pages, PDFs, images, videos, etc.) via a process known as:</p>
<ol>
<li>Crawling: Scour the Internet for content, looking over the code/content for each URL they find.</li>
<li>Indexing: Store and organize the content found during the crawling process. Once a page is in the index, it’s in the running to be displayed as a result to relevant queries.</li>
<li>Ranking: Ordering it by how well it matches the query and provide the pieces of content that will best answer a searcher’s query</li>
</ol>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Spanning Trees(MST), Kruskal and Prim algorithm</title>
    <url>/Minimum%20Spanning%20Trees(MST),%20Kruskal%20and%20Prim%20algorithm.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>万恶的算法作业，要找寻一条边是否在MST中，看似简单，却暗藏玄机，因为一个graph可能不止有一个MST，用Kruskal 算法找到MST固然简单，但找到所有MST似乎就只能用Prim了。不想删掉我辛辛苦苦写的Kruskal算法，便写了这篇文章作为总结。</p>
<a id="more"></a>
<p>题目</p>
<blockquote>
<p>[python3] (7 points) Devise, then code in python 3, a efficient algorithm for the following problem. Inputs: (i) a connected weighted undirected graph G = ⟨V,E⟩, and, (ii) an edge e ∈ E. Output: true if there is a minimum spanning tree of G that contains e, and false otherwise. G is provided in adjacency list format, and e as a list which encodes a pair. E.g., an encoding of the following graph is [[[3,10], [1,100], [2, 20]], [[0,100]], [[0,20],[3,10]], [[2,10],[0,10]]], and the output is false for edge [2,0] and true for edge [0,1]. </p>
<p><img src="https://imgur.com/lrwEByp.jpg" alt></p>
</blockquote>
<ol>
<li>Kruskal</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mstexists</span><span class="params">(G, e)</span>:</span></span><br><span class="line">		<span class="comment"># to re-organize input G into edges</span></span><br><span class="line">    edges = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(G)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(G[i])):</span><br><span class="line">            f = G[i][j][<span class="number">0</span>]</span><br><span class="line">            w = G[i][j][<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># avoid the situation that adding two same edge, like(1,2),(2,1)</span></span><br><span class="line">            edge = sorted([i, f]) </span><br><span class="line">            edge.append(w)</span><br><span class="line">            <span class="keyword">if</span> edge <span class="keyword">not</span> <span class="keyword">in</span> edges:</span><br><span class="line">                edges.append(edge)</span><br><span class="line"></span><br><span class="line">    edges = sorted(edges, key = <span class="keyword">lambda</span> x:x[<span class="number">2</span>]) </span><br><span class="line">    <span class="comment"># Kruskal algorithm: choose edge with increase order of edge's weight</span></span><br><span class="line">    mem = [] <span class="comment"># to record vertice which have been added into MST</span></span><br><span class="line">    MST = [] <span class="comment"># to record edges which have been added into MST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        s = edge[<span class="number">0</span>]</span><br><span class="line">        f = edge[<span class="number">1</span>]</span><br><span class="line">        w = edge[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> mem <span class="keyword">or</span> f <span class="keyword">not</span> <span class="keyword">in</span> mem: <span class="comment"># not a cycle</span></span><br><span class="line">            mem.append(s)</span><br><span class="line">            mem.append(f)</span><br><span class="line">            MST.append([s,f])</span><br><span class="line">        <span class="keyword">if</span> len(set(mem)) == len(G):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted(e) <span class="keyword">in</span> MST</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Prim</li>
</ol>
<p>用于寻找所有的 MST 所包含的边。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mstexists</span><span class="params">(G, e)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    You need to implement this method.</span></span><br><span class="line"><span class="string">    G is an adjacency list in the format discussed in the handout</span></span><br><span class="line"><span class="string">    e is a list of two items, e.g., [0,4]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    MST = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> range(len(G)):</span><br><span class="line">        Prim(s, G, MST)</span><br><span class="line">        <span class="comment"># print(MST)</span></span><br><span class="line">    <span class="comment"># print(sorted(e) in MST)</span></span><br><span class="line">    <span class="keyword">return</span> sorted(e) <span class="keyword">in</span> MST</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Prim</span><span class="params">(s, G, MST)</span>:</span></span><br><span class="line">    <span class="comment"># initialization</span></span><br><span class="line">    key = [float(<span class="string">'inf'</span>)] * len(G)</span><br><span class="line">    Q = []</span><br><span class="line">    mem = [] <span class="comment"># keep track of vertices already included in MST</span></span><br><span class="line">    key[s] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> G[s]:</span><br><span class="line">        Q.append([s, edge[<span class="number">0</span>], edge[<span class="number">1</span>]]) <span class="comment"># [start, finish, weight]</span></span><br><span class="line">    Q = sorted(Q, key = <span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">    mem.append(s)</span><br><span class="line">    <span class="keyword">while</span> len(mem) != len(G):</span><br><span class="line">        nxt = Q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> nxt[<span class="number">1</span>] <span class="keyword">in</span> mem:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        e = sorted([nxt[<span class="number">0</span>], nxt[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">if</span> e <span class="keyword">not</span> <span class="keyword">in</span> MST:</span><br><span class="line">            MST.append(e)</span><br><span class="line">        mem.append(nxt[<span class="number">1</span>])</span><br><span class="line">        s = nxt[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> G[s]:</span><br><span class="line">            f = edge[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> f <span class="keyword">not</span> <span class="keyword">in</span> mem:</span><br><span class="line">                Q.append([s, f, edge[<span class="number">1</span>]])  <span class="comment"># [start, finish, weight]</span></span><br><span class="line">        Q = sorted(Q, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>亮点：1. 使用sorted避免加入重复边。</p>
]]></content>
      <tags>
        <tag>Algorithm算法</tag>
      </tags>
  </entry>
  <entry>
    <title>What is &#39;cut and paste&#39; in proving algorithm 算法证明中的‘复制粘贴法’到底是啥</title>
    <url>/what%20is%20&#39;cut%20and%20paste&#39;%20in%20proving%20algorithm.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>I encounter this ‘cut and paste’ in my algorithm course, so I searched some information to and found <a href="https://stackoverflow.com/questions/9553162/what-is-the-cut-and-paste-proof-technique" target="_blank" rel="noopener">this explaination</a> is good.</p>
<p><a href="https://stackoverflow.com/questions/9553162/what-is-the-cut-and-paste-proof-technique" target="_blank" rel="noopener">这里</a>解释的很好，简单来说，当你想用证明一些算法（大多数情况是动态规划和贪心算法）的正确性时就可以利用矛盾法contradiction和复制粘贴大法cut and paste。因为动态规划或贪心算法都是建立在取最优结果的基础上完成下一步的计算，所以你需要假设我们其中某一步不采用前面的最优结果也可以达到最优的效果，那我们就先cut掉某一步的最优结果，将次优结果paste上去，从而进行推导，得到我们想要的contradiction就大功告成证明成功。</p>
<a id="more"></a>

<blockquote>
<p>The term “cut and paste” shows up in algorithms sometimes when doing dynamic programming (and other things too, but that is where I first saw it). The idea is that in order to use dynamic programming, the problem you are trying to solve probably has some kind of underlying redundancy. You use a table or similar technique to avoid solving the same optimization problems over and over again. Of course, before you start trying to use dynamic programming, it would be nice to prove that the problem has this redundancy in it, otherwise you won’t gain anything by using a table. This is often called the “optimal subproblem” property (e.g., in CLRS).</p>
</blockquote>
<blockquote>
<p>The “cut and paste” technique is a way to prove that a problem has this property. In particular, you want to show that when you come up with an optimal solution to a problem, you have necessarily used optimal solutions to the constituent subproblems. The proof is by contradiction. Suppose you came up with an optimal solution to a problem by using suboptimal solutions to subproblems. Then, if you were to replace (“cut”) those suboptimal subproblem solutions with optimal subproblem solutions (by “pasting” them in), you would improve your optimal solution. But, since your solution was optimal by assumption, you have a contradiction. There are some other steps involved in such a proof, but that is the “cut and paste” part.</p>
</blockquote>
]]></content>
      <tags>
        <tag>Algorithm算法</tag>
      </tags>
  </entry>
  <entry>
    <title>看缠中说禅博客有感</title>
    <url>/%E7%9C%8B%E7%BC%A0%E4%B8%AD%E8%AF%B4%E7%A6%85%E5%8D%9A%E5%AE%A2%E6%9C%89%E6%84%9F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>随便写写，反正也没人看。</p>
<a id="more"></a>

<p>和母上聊天提到了他，印象中是个传奇的人物，但今天才去他的博客仔细读了读他的文章。首先坦白来说对于股市我并不是很懂，但对于投资理财这一块自己的确也比较感兴趣，他的缠论我也听说过，谁能想到十年前的东西，现在依然适用？看来十年过去了人们依然没有多少进步，无论是指理论的深入还是投资的理性。缠论以后有时间一定要细细研读。</p>
<p>缠中说禅真得很有意思，以女性的身份发博客，去抨击男同，男权，用现在的眼光看来可谓是女拳楷模，但谁又能想到他是个男人呢？明明每篇文章男性的强烈情感都如此浓郁，言辞也十分激烈，一语双关的黄色笑话也似乎只有男人才开的出来。那些还是把他当作女性的人是不是早就被他在屏幕后嘲笑的体无完肤了？不得不说<a href="http://blog.sina.com.cn/s/blog_486e105c010002f2.html" target="_blank" rel="noopener">这篇12年前的文章</a>现在看来也说的真是很对。过分的左也不一定是好事，弱势群体真的是弱势还是在仗势欺人？由同性恋也可以推广至女拳，动物保护，难民等问题。</p>
<p>观看下面的留言，十年前的网友留言素质可是比如今微博，天涯等网友的高得多多了。虽然仍有无脑sb.但大多数人反驳别人观点时至少能拿出点理论依据。可能是现在科技发展了，是个阿猫阿狗都能上来抒发一下情感了吧，笑。</p>
<p>有才华的人大多是有点傲气的，文风犀利，观点毒辣，一套说辞堵得你哑口无言。可有些人却把这层关系弄反了，以为自己的傲气是有才华的证明，呵呵，所以他们从对生活产生不满，戾气很重，认为现在拥有的一切配不上自己的才华，对此我只能说声活该，以及告诉自己不要和这种sb.走的太近，徒增戾气。</p>
]]></content>
      <tags>
        <tag>Essay杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 79. word search</title>
    <url>/Leetcode%2079.%20word%20search.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Rewrite it again during a mock interview. Then I found myself is just a small potato. So write it down to record some mistakes and weakness. </p>
<a id="more"></a>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">[&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">[&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>

<h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p>coderpad：share screen and code, need to write IO by yourself. only the print part can be shown on the screen, which mean totally different from Leetcode.</p>
<ol>
<li>Write IO, class by yourself</li>
<li>return content will not be shown on screen, if you want print something on screen, you definitely need to write “print”</li>
<li>remember to use your function</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FindWord</span><span class="params">(board, word)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    m = len(board)</span><br><span class="line">    n = len(board[<span class="number">0</span>])</span><br><span class="line">    visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> DFS(board, visited, word, i, j):</span><br><span class="line">                print(<span class="string">"true"</span>) <span class="comment"># definitely need to write "print"</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"false"</span>) <span class="comment"># definitely need to write "print"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(board, visited, word, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> i == len(board) <span class="keyword">or</span> j == len(board[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> visited[i][j] <span class="keyword">or</span> board[i][j] != word[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i][j] <span class="keyword">and</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">        visited[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> DFS(board, visited, word[<span class="number">1</span>:], i<span class="number">-1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">        DFS(board, visited, word[<span class="number">1</span>:], i+<span class="number">1</span>, j) <span class="keyword">or</span> \</span><br><span class="line">        DFS(board, visited, word[<span class="number">1</span>:], i, j<span class="number">-1</span>) <span class="keyword">or</span> \</span><br><span class="line">        DFS(board, visited, word[<span class="number">1</span>:], i, j+<span class="number">1</span>) <span class="comment"># Using or</span></span><br><span class="line">        visited[i][j] = <span class="literal">False</span> <span class="comment"># backtacking part</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">board = [[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],[<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],[<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]]</span><br><span class="line">word = <span class="string">"ABCB"</span> </span><br><span class="line">FindWord(board, word)</span><br></pre></td></tr></table></figure>

<h3 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity:"></a>Time complexity:</h3><p>numOfRows: m, numOfCols: n, LengthOfWord: l</p>
<p>beacause we have n*m elements which could be the start point. and each start point could run into four different directions. So the worst-case time complexity is </p>
<p>O(m<em>n</em>4^l)</p>
<h3 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h3><p>we need visited to store, so the space complexity is O(n)</p>
<h3 id="What-is-recursion"><a href="#What-is-recursion" class="headerlink" title="What is recursion"></a>What is recursion</h3><p>For this question, in order to record whether this letter has been visited. we should make full use of recursion. and the most important part of recursion is <strong>Backtracking</strong>. Where to write backtracking part? It is depend on your recursion function. For this question, put backtracking part on the end of recursion. Because we have finished all recursion and return the answer. For the next start point, we need a new visited array to record it, to reuse the visited array again. </p>
<p><strong>return part</strong> is always important during recursion. Figure out what you want to return. if the answer is True or False, figure out the Logic. </p>
<p>eg. </p>
<p>1) using recursion to find whether we have sth. in sp., the logic is ‘or’ between different recursion statement. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursionFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">statement1</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> statement2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> recursionFunction() <span class="keyword">or</span> recursionFunction()</span><br></pre></td></tr></table></figure>

<p>2) using return to transfer value, may use +=. Like </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursionFunction</span><span class="params">()</span></span></span><br><span class="line">    res += recursionFunction()</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>3) or we don’t need to return anything, beacause we have find answer in other if statement:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursionFunction</span><span class="params">(combi, res)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">statement1</span>:</span></span><br><span class="line">        res.append(combi)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">elif</span> statement2:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        recursionFunction(combi+sth1, res) </span><br><span class="line">        recursionFunction(combi+sth2, res) </span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a>Conclusion:</h3><ol>
<li>Copy the others code from discussion is helpless for solve problem truly. But if meet hard problem, you can refer to others, but must be rewrite again by yourself.</li>
<li>Calculate time complexity and space complexity by yourself <strong>each time</strong></li>
<li>Coding style: <a href="https://www.tutorialspoint.com/python/python_if_else.htm" target="_blank" rel="noopener">when to use if and elif</a>: if&amp;elif is something like switch case, and elif can be used many times, but in if&amp;else, else can only be used once. In both of them, if ‘if’ has been tested and entered, the rest will not be tested. So they can be used to write some contradict requirements. But for if&amp;if, each if will be tested, no matter whether another one has been tested. </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 128 Longest Consecutive Sequence</title>
    <url>/LeetCode-128-Longest-Consecutive-Sequence.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">here</a></h1><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(<em>n</em>) complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><ol>
<li>set (hashmap)</li>
</ol>
<p>因为要保证O(n)的时间复杂度，所以可以使用set先来保存一下list。这样对每个元素的查询就都是O(1)的时间。</p>
<p>当想要知道最长的连续元素时，我们需要先取n， 然后找他的n-1, n+1在不在set中，但这样难免出现重复查找的情况，比如一串数字3456，无论n遍历到哪一个数字，都会把其他的再查一遍，为了减少这种情况的出现。我们不如直接找到这串数字的开头，也就是3。如何找呢？我们就去找2，也就是（n-1）在不在set中，不在，那3肯定就是开头，那代码也就能出来了，凡是遍历n时n-1在set中，那就直接跳过，只去寻找那些是开头的数字后面到底跟了多少数。结果取最长的</p>
<h1 id="Final-Code"><a href="#Final-Code" class="headerlink" title="Final Code"></a>Final Code</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">nums = set(nums)</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line"><span class="keyword">if</span> x<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">y = x+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> y <span class="keyword">in</span> nums:</span><br><span class="line">y += <span class="number">1</span></span><br><span class="line">ans = max(ans, y-x)</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 965 Univalued Binary Tree</title>
    <url>/LeetCode-965-Univalued-Binary-Tree.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">here</a></h1><p>A binary tree is univalued if every node in the tree has the same value.<br>Return true if and only if the given tree is univalued.<br>简而言之，判断问二叉树的每个节点的值是不是都是一样的。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><p>Input: [1,1,1,1,1,null,1]<br>Output: true<br>这题和上次的100很像，但100是比较两个二叉树的，这题是比较自身的值是否一致。所以大致思路会延续上次100，但会有细微不同。</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>这一篇是当时接着100写的，也算是刚入leetcode坑时代码讲解之一。所以写的很细，也会指出一些新手（自己）常犯的错误。</p>
<h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><p>当使用递归刷题时，就不可避免的会用到函数的互相调用，<a href="https://blog.csdn.net/CLHugh/article/details/75000104" target="_blank" rel="noopener">这里</a>是是讲class内部函数调用的，可以看看</p>
<p><strong>递归有两大部分：终点（递归出口，逻辑边界）和自身调用部分（递归表达式，规律等）<br>写好一个递归算法要把握三个方面：1.提取重复逻辑 2.合适的退出条件3.控制逻辑边界。</strong><br>（copy上次的，拿过来再强调一下）</p>
<h3 id="终点："><a href="#终点：" class="headerlink" title="终点："></a>终点：</h3><ol>
<li>合适的退出条件：<br>发现左支或右支与当前节点的值不同，return 0<br>注意： 这里自己写很容易写错成（root.val != root.right）,思考题：为什么这样写是不对的？正确答案应该怎么写？<br>答案：正确写法：（root.val != root.right.val）<br>root.right是右支，而不是右支节点值。root.val 肯定是一直都不会等于root.right的，即treeNode != val。</li>
<li>控制逻辑边界<br>当两个二叉树都为空时，即递归到了叶子结点时，return 1。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="自身调用部分："><a href="#自身调用部分：" class="headerlink" title="自身调用部分："></a>自身调用部分：</h3><ol start="3">
<li>提取重复逻辑：<br>这题的重复逻辑就是不断的判断左支或右支与当前节点的值是否相同，因为该逻辑可以直接写在if的判断语句中，所以当if判断完成后直接就是return，中间没有额外的计算操作。</li>
</ol>
<p><strong>所以这一题的重点就是在与如何写if判断语句，也就是下面的when</strong></p>
<p><strong>When何时用这部分</strong>:我觉得要是理不清怎么写，一定要先把左支和右支分开写，至少条理会清楚点。If判断语句也不要写太长。我当时第一次左右放一起写就导致忘记某些特殊case。<br>错误示范： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.right <span class="keyword">and</span> (root.left.val != root.val <span class="keyword">or</span> root.right.val != root.val):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>正确示范：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root.right <span class="keyword">and</span> root.val != root.right.val:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> root.left <span class="keyword">and</span> root.val != root.left.val:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>何时对自身进行调用：即不是叶子结点，也没有遇到不同值时，也就是else</p>
<p><strong>How这部分怎么计算</strong>: 基本没什么计算部分，省略</p>
<p><strong>What返回什么</strong>:<br>return 1: 当递归到了叶子结点时<br>return 0:值不一样时<br>return result: 用and逻辑连接左右两支的递归返回结果。</p>
<h1 id="Final-Code"><a href="#Final-Code" class="headerlink" title="Final Code"></a>Final Code</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.univalued(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">univalued</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.val != root.left.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> root.val != root.right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = self.univalued(root.left) <span class="keyword">and</span> self.univalued(root.right)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/85385974#_46" target="_blank" rel="noopener">这里</a>和<a href="https://blog.csdn.net/chlele0105/article/details/38759593" target="_blank" rel="noopener">这里</a>是用BFS和DFS解决二叉树问题</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 739 Daily Temperature</title>
    <url>/LeetCode-739-Daily-Temperature.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">here</a></h1><p>Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.<br>For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</p>
<p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].<br>简而言之，判断过几天天气才能回暖。</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>首先一看到题目大家想到的方法肯定是遍历，套两层循环暴力搜索气温升高的那天，然后坐标相减得出结果。但是注意Note里面说了可能会有30000天的温度，所以这条路就被否决掉了。但是这并不代表遍历不行，转换角度从温度进行遍历就会快很多。详细可参考<a href="https://blog.csdn.net/fuxuemingzhu/article/details/79285081" target="_blank" rel="noopener">这个微博</a></p>
<p>但是作为一个优雅的程序员，光写这种代码肯定是不行的。所以今天我们就要用堆栈stack来解决这道题。</p>
<p>其实要我自己写我肯定也想不到要用堆栈，但是看完别人的代码后就发现用堆栈还是有一定道理的。堆栈的先进后出和pop功能可以有效的再只遍历一次的情况下得到结果。</p>
<h2 id="堆栈-stack"><a href="#堆栈-stack" class="headerlink" title="堆栈 stack"></a>堆栈 stack</h2><p>我们以题目中给出的例子为例来讲解：[73, 74, 75, 71, 69, 72, 76, 73]。<br>我们定义一个空栈和全零的output list，然后在用for循环遍历温度的时候分别做如下处理：</p>
<ol>
<li><p>如果第二天的温度比当天的低，那么我们暂时还无法确定需要等多少天才能有更高的温度，所以就将当天的温度入栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack.append(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果第二天温度比当天的高，那么它需要等待的天数就是1（如当t=74，栈顶元素为73时）。此时我们需要更新栈顶元素对应的那天的等待时间，把结果放进output list里。即当t=74，栈顶元素为73时，其对应结果为1（output[cur] = i-cur），此时由于73已经找到结果，所以要被pop出；当t=75的时候同理</p>
</li>
</ol>
<p>当t=71时，由于71&lt;75 情况1），所以我们将75入栈（此时栈内元素为75）。<br>当t=69时，由于69&lt;71 情况1），71也同理入栈（此时栈内元素为75,71）。<br>当t=72时，由于69&lt;72 情况2），所以69的对应结果为1且69找到答案被pop出栈。当前栈顶元素为71，然后71&lt;72，所以此时可以修改71对应的等待天数，即为72对应的天数索引与71对应的天数索引，然后71出栈（此时栈内元素为75）；<br>当t=76时，由于71&lt;76 情况2），结果为1，但是同时由于76大于栈顶元素75，所以修改75的等待天数，并出栈（此时栈内为空）。<br>当t=73时，由于76&gt;73 情况1）76需入栈。由于再也没有比76大的元素，并且73之后也没有元素了，所以76，73对应的等待天数就都为0了，在程序中并没有做处理。</p>
<p><strong>注</strong>：使用enumerate可以同时获得下标i和温度t。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i, t in enumerate(T):</span><br></pre></td></tr></table></figure>

<p>算法的空间复杂度为O(n)，时间复杂度也为O(n)，这是因为for循环里面的while循环中，每个元素最多出一次栈，所以while总的执行次数是O(n)量级的。</p>
<h1 id="Final-Code"><a href="#Final-Code" class="headerlink" title="Final Code"></a>Final Code</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T)</span>:</span></span><br><span class="line">        output = [<span class="number">0</span>] * len(T)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(T):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[stack[<span class="number">-1</span>]] &lt; t:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                output[cur] = i-cur</span><br><span class="line"></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 144.Binary Tree Preorder Traversal</title>
    <url>/LeetCode-144-Binary-Tree-Preorder-Traversal.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">here</a></h1><p>Given a binary tree, return the preorder traversal of its nodes’ values.<br>简而言之，用<strong>前序</strong>输出二叉树，至于什么是前序preorder，中序inorder和后序postorder，click <a href="https://en.wikipedia.org/wiki/Tree_traversal" target="_blank" rel="noopener">here</a></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><pre><code>Input: [1,null,2,3]
  1
   \
    2
   /
  3
Output: [1,2,3]</code></pre><p>这一题用递归很简单，遍历就行，但因为遍历有两个常用的方法：一是递归(recursive)，二是使用栈实现的迭代版本(stack+iterative)。这两种方法都是O(n)的空间复杂度（递归本身占用stack空间或者用户自定义的stack），那但如何使空间复杂度为O（1）呢？</p>
<p>This problem is very simple to use recursion, traversal all of them. but because there are two common methods for traversal: one is recursive, and the other is iterative version using stack implementation (stack + iterative). These two methods are both O (n) space complexity (recursion itself occupies stack space or user-defined stack), but how to make the space complexity O (1)?</p>
<a id="more"></a>

<h1 id="Solution-Morris-Traversal"><a href="#Solution-Morris-Traversal" class="headerlink" title="Solution: Morris Traversal"></a>Solution: Morris Traversal</h1><p>参考了<a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">这里</a>，和<a href="https://ghh3809.github.io/2018/08/06/morris-traversal/" target="_blank" rel="noopener">这里</a>，文章写的很好，可以看一看。<br>这是一个神奇的算法，可以解决两个问题</p>
<ol>
<li>使用O(1)空间复杂度，即使用常数空间（同时时间复杂度是O(n)）；</li>
<li>不破坏二叉树的形状（中间过程允许改变其形状）</li>
</ol>
<p>要使用O(1)空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针），由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。</p>
<p>虽然这一题是做前序，但我想主要讲一下<strong>中序</strong>遍历是如何实现的，因为morris traversal就是在中序基础上写的，前序和后序可以参考前面那篇文章。不想读文章的我也可以总结一下：<strong>三种遍历在整体流程实现上是一模一样的，唯一不同在于何时去输出节点（前序与中序主要区别），或是否要反向print反向print是后序的特点</strong>。文章里用的是C++，而我用的是Python，不过思路都是一样的。</p>
<p>首先要明白什么是中序遍历：核心：visit child before parent</p>
<ol>
<li>若节点还有左<strong>子树</strong>，就要先把左子树访问完</li>
<li>没有左子树可访问时，访问该节点，并尝试访问右子树</li>
</ol>
<p><img src="https://imgur.com/lldvZuC.jpg" alt><br>In-order: 0,1,2,3,4,5,6<br>每一个节点都有“前驱”节点和“后继”节点。例如在示例的二叉树上，0是1的前驱节点，而2是1的后继节点。显然，中序遍历可以转化为对后继节点的计算过程。后继节点的计算方法为：</p>
<ol>
<li>对于存在右子树的节点A，其后继节点是其右子树中最左侧的节点；</li>
<li>对于没有右子树的节点B，其后继节点是其自下而上的父节点中第一个将其作为左子树的节点。</li>
</ol>
<p>节点A的后继计算非常简单。然而由于二叉树的信息中不包括父节点的信息，因此第2条操作起来非常困难，这也是为何之前采用了栈/队列的方式存储父节点的信息。<strong>但是倒过来想，虽然节点1不知道节点2是它的后继节点，但是节点2知道节点1是它的前驱节点啊，所以我们可以通过在节点2时就去找它的前驱节点（节点1），找到后我们就可以暂时使用节点1右子树的链接，存储后继节点（节点2），以实现对后继节点的直接获取，同时不占用额外的空间</strong>。这就是Morris遍历算法的主要思想。</p>
<p>根据上述分析，我们可以写出程序的主要计算过程：</p>
<ol>
<li>如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。</li>
<li>如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前继节点。<ul>
<li>如果前继节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。</li>
<li>如果前继节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。</li>
</ul>
 <strong>从这我们也可以注意到此条路径会被遍历两遍，一遍用来标记，一遍用来恢复</strong></li>
<li>重复以上1、2直到当前节点为空。<br><img src="https://imgur.com/7UJKYGT.jpg" alt></li>
</ol>
<p>以下是前序遍历代码，但是和中序除了输出位置不一样，其他没有任何差别。</p>
<h1 id="Final-code"><a href="#Final-code" class="headerlink" title="Final code:"></a>Final code:</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = root   <span class="comment">#仅存放两个临时变量，O(1)空间复杂度</span></span><br><span class="line">        <span class="keyword">while</span>(cur):   <span class="comment">#当前节点为空时，说明访问完成</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:   <span class="comment">#左子树不存在时，访问+进入右节点</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:   <span class="comment">#左子树存在，寻找前驱节点。</span></span><br><span class="line">                prev = cur.left</span><br><span class="line">                <span class="keyword">while</span>(prev.right <span class="keyword">and</span> prev.right != cur): <span class="comment">#注意寻找前驱节点时，会不断深入右子树。不加判断时，若前驱节点的右子树已指向自己，会引起死循环</span></span><br><span class="line">                    prev = prev.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev.right:  <span class="comment">#前驱节点未访问过，存放后继节点</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    prev.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># prev.right == cur 前驱节点已访问过，恢复树结构</span></span><br><span class="line">                    prev.right = <span class="literal">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题中如何添加音乐</title>
    <url>/Hexo-NexT%E4%B8%BB%E9%A2%98%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>搭建Blog的第三天，为了提升逼格，开始考虑给博客加点背景音乐，文章音乐等。此篇文章就是记录并分享一下如何在NexT主题中添加音乐。<br>首先需要感谢丰富的互联网资源，让我这种不是科班出生的人都可以搭建属于自己的网站，感谢感恩感动。<br>此篇文章仅讨论如何在Hexo，next主题下添加音乐。所以默认大家都已经搭建好平台了。关于这部分我就不多赘述了，可能以后会出平台搭建教程（先挖个坑）。</p>
]]></content>
      <tags>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>远方与家乡</title>
    <url>/%E8%BF%9C%E6%96%B9%E4%B8%8E%E5%AE%B6%E4%B9%A1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>到不了的都叫做远方，回不去的名字叫家乡</p>
<a id="more"></a>
<p>南拳妈妈的歌如今听来也不落俗，方文山写的词真是把人心攥的死死的。</p>

    <div id="aplayer-GvuiNEfE" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="368794" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

<p>牛肉锅贴，每次去那门口都排满人。<br><img src="https://imgur.com/3pc18aq.jpg" alt><br>梧桐树，主干道上的树龄应该快百年了。<br><img src="https://imgur.com/ZPcWFjR.jpg" alt><br>买酒的路上遇的街头歌手。等我技艺纯熟了我也要这么干。<br><img src="https://imgur.com/rDTBFml.jpg" alt><br>某个港口，明明太阳当空，却被港口的风吹冻死。<br><img src="https://imgur.com/A8L9HK3.jpg" alt><br>野餐烧烤，香肠还挺好吃<br><img src="https://imgur.com/rRHSpxY.jpg" alt><br>农场，就，很大<br><img src="https://imgur.com/UC6DD98.jpg" alt><br>都是在车里拍的，所以两张图都有横向的运动感，为了保持图片风格一致和突出这种感觉，拼接就也采用横向，同时不保留接缝。<br><img src="https://imgur.com/td5EuBP.jpg" alt><br>pan cake 还不错，berry太酸。馄饨这家也是老店，哪怕亲眼目睹恶劣的卫生环境，但每次路过还是会来吃。<br><img src="https://imgur.com/73DNzi4.jpg" alt><br>手机翻出来这两张，不同时间不同地点，但构图与内容竟然初期一致的图，于是就拿来进行拼接。本来是正常的上下拼接，但是因为两张图中间的界限不能对齐，且整体会有失衡的感觉，就考虑采用左右翻转拼接，但是这样上面的字就也跟着反了。最后灵光一现，采用上下翻转拼接，但因为界限还是对不上，所以保留中间的白色接缝。<br><img src="https://imgur.com/cOwjial.jpg" alt></p>
]]></content>
      <tags>
        <tag>Essay杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100.the same tree</title>
    <url>/LeetCode-100-the-same-tree.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Question-here"><a href="#Question-here" class="headerlink" title="Question: here"></a>Question: <a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">here</a></h1><p>Given two binary trees, write a function to check if they are the same or not.<br>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.<br>总而言之，就是判断两颗二叉树是否一模一样。左右枝哪怕数字一样顺序不一样都是不行的。<br>It is my first time to use recursion to solve a question, So i will use most of content to explain how to writer a good recursion.</p>
<a id="more"></a>
<h1 id="Solution-Recursion-递归"><a href="#Solution-Recursion-递归" class="headerlink" title="Solution: Recursion (递归)"></a>Solution: Recursion (递归)</h1><p><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" target="_blank" rel="noopener">What’s recursion?</a> From wiki we noticed that recursion is different from <a href="https://en.wikipedia.org/wiki/Iteration#Computing" target="_blank" rel="noopener">iteration(迭代)</a> which repeats a process instead of function to generate the output.</p>
<p>There are two main parts of recursion: the end point (recursive exit, logical boundary) and the own call part (recursive expression, regular, etc.)</p>
<p>When write a recursive algorithm, three aspects need to be paid attention: </p>
<ul>
<li>Extract the repetitive logic. </li>
<li>Appropriate exit conditions. </li>
<li>Control the logical boundaries.</li>
</ul>
<p>End point: (I usually write the end point first, because it is easier to think and write)</p>
<ul>
<li>Appropriate exit conditions: Find a different node, return 0</li>
<li>Control logic boundaries: Return 1 when both binary trees are empty, that is, recursively to the leaf node.</li>
</ul>
<p>The own call part:</p>
<ul>
<li>Extract the repeating logic: The repetition logic of this problem is obvious, that is, to determine whether the values of each node are equal. <code>p.val = q.val</code></li>
</ul>
<h2 id="When-to-use-this-part"><a href="#When-to-use-this-part" class="headerlink" title="When to use this part:"></a><strong>When</strong> to use this part:</h2><p>Of course, it must be not reaching to end point. However, this question cannot be considered only in addition to the recursive end point, because this question needs to compare the val of the node. So NoneType object (leaf node) needs to be excluded.<br>    <code>if (p.val == q.val) and p and q:</code><br>Otherwise, <strong>Line 21: AttributeError: ‘NoneType’ object has no attribute ‘val’</strong></p>
<p>Then you may have a doubt, we have already considered it when controlling the logical boundaries, why consider it again? It should be noted that previously, we considered the senario that two binary trees are empty at the same time. But when one is empty and the other has value, it is easy to encounter a bug. such as the testcase like this: <code>[1,2] [1,null,2]</code><br>What I want to point out that <code>if p and q and (p.val == q.val)</code> this judgment statement is also very clever, because you must pay attention to the order of judgment, such as writing <code>if (p.val == q.val) and p and q:</code>will report an error. <strong>DO YOU KNOW WHY?</strong></p>
<h2 id="How-to-calculate-this-part"><a href="#How-to-calculate-this-part" class="headerlink" title="How to calculate this part:"></a><strong>How</strong> to calculate this part:</h2><p>When the node values of the two trees are the same, you can recursively judge their nodes, and record the judgment result of the child nodes.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (p.val == q.val) and p and q: </span><br><span class="line">    result = self.same(p.left, q.left) and self.same(p.right, q.right)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<h2 id="What-to-returns"><a href="#What-to-returns" class="headerlink" title="What to returns:"></a><strong>What</strong> to returns:</h2><p>Return 1: when both binary trees are empty, in other words, reach to the leaf node<br>Return 0: when the nodes are different<br>Return result: Using <code>and</code> to combine tow results from the left and right sides.</p>
<h1 id="Final-code"><a href="#Final-code" class="headerlink" title="Final code:"></a>Final code:</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.same(p, q)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.val == q.val) <span class="keyword">and</span> p <span class="keyword">and</span> q: </span><br><span class="line">            result = self.same(p.left, q.left) <span class="keyword">and</span> self.same(p.right, q.right)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, My World</title>
    <url>/Hello-My-World.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://imgur.com/2Ws9fLk.jpg" alt></p>
<h2 id="这是属于我的世界"><a href="#这是属于我的世界" class="headerlink" title="这是属于我的世界"></a>这是属于我的世界</h2><p>某天晚上和同学聊天，突然意识到拥有一个技术Blog应该是程序员的基本素养，所以废寝忘食，披星戴月（并没有）地弄了一个。身为拖延症晚期，懒癌晚期的咸鱼一条，竟然在搭建自己博客的时候感受无与伦比的成就感，冥冥之中觉得自己应该能坚持更新（先立个flag）说不定以后会自己写一个Hexo主题（另一个flag）<br>介绍一下自己，小Pia同学，新晋程序媛一枚。通信转来写代码，非学院派，谷歌自学ing。🇨🇦研究生在读。本博客用来记录学习笔记和分享日常生活，毕竟父母亲戚朋友肯定搜不到这个网站，所以应该也会用肆意来吐槽（坏笑）<br>出于以后找工作考虑，学习笔记部分应该会首选英文或中英结合？其他部分就比较随意。</p>
]]></content>
      <tags>
        <tag>Essay杂记</tag>
      </tags>
  </entry>
</search>
